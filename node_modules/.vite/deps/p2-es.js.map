{
  "version": 3,
  "sources": ["../../p2-es/dist/p2-es.js"],
  "sourcesContent": ["/**\n * The array type to use for internal numeric computations throughout the library.\n * Float32Array is used if it is available, but falls back on Array.\n * If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE.\n * See example below.\n *\n * @example\n *     <script>\n *         <!-- Inject your preferred array type before loading p2-es -->\n *         P2_ARRAY_TYPE = Array;\n *     </script>\n *     <script src=\"p2-es.js\"></script>\n */\nconst ARRAY_TYPE = (() => {\n  if (typeof P2_ARRAY_TYPE !== 'undefined') {\n    return P2_ARRAY_TYPE;\n  } else if (typeof Float32Array !== 'undefined') {\n    return Float32Array;\n  } else {\n    return Array;\n  }\n})();\n\n/**\n * Append the values in array b to the array a.\n * @param a the array to append to\n * @param b the array to append values from\n */\nconst appendArray = (a, b) => {\n  for (let i = 0, len = b.length; i !== len; ++i) {\n    a.push(b[i]);\n  }\n};\n\n/**\n * Garbage free Array.splice(). Does not allocate a new array.\n * @param array\n * @param index\n * @param howmany\n */\nconst splice = function (array, index, howmany) {\n  if (howmany === void 0) {\n    howmany = 1;\n  }\n  const len = array.length - howmany;\n  for (let i = index; i < len; i++) {\n    array[i] = array[i + howmany];\n  }\n  array.length = len;\n};\n\n/**\n * Remove an element from an array, if the array contains the element.\n * @param array\n * @param element\n */\nconst arrayRemove = (array, element) => {\n  const idx = array.indexOf(element);\n  if (idx !== -1) {\n    splice(array, idx, 1);\n  }\n};\n\n/**\n * Extend an object with the properties of another\n * @param a\n * @param b\n */\nconst extend = (a, b) => {\n  return {\n    ...a,\n    ...b\n  };\n};\n\n/**\n * Shallow clone an object. Returns a new object instance with the same properties as the input instance.\n * @param obj\n */\nconst shallowClone = obj => {\n  return extend({}, obj);\n};\n\nvar Utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ARRAY_TYPE: ARRAY_TYPE,\n    appendArray: appendArray,\n    arrayRemove: arrayRemove,\n    extend: extend,\n    shallowClone: shallowClone,\n    splice: splice\n});\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n\n/**\n * Make a cross product and only return the z component\n * @param a\n * @param b\n * @return\n */\nfunction crossLength(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @param out\n * @param vec\n * @param zcomp\n * @return\n */\nfunction crossVZ(out, vec, zcomp) {\n  rotate(out, vec, -Math.PI / 2); // Rotate according to the right hand rule\n  scale(out, out, zcomp); // Scale with z\n  return out;\n}\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @param out\n * @param zcomp\n * @param vec\n * @return\n */\nfunction crossZV(out, zcomp, vec) {\n  rotate(out, vec, Math.PI / 2); // Rotate according to the right hand rule\n  scale(out, out, zcomp); // Scale with z\n  return out;\n}\n\n/**\n * Rotate a vector by an angle\n * @param out\n * @param a\n * @param angle\n * @return\n */\nfunction rotate(out, a, angle) {\n  if (angle !== 0) {\n    const c = Math.cos(angle),\n      s = Math.sin(angle),\n      x = a[0],\n      y = a[1];\n    out[0] = c * x - s * y;\n    out[1] = s * x + c * y;\n  } else {\n    out[0] = a[0];\n    out[1] = a[1];\n  }\n  return out;\n}\n\n/**\n * Rotate a vector 90 degrees clockwise\n * @param out\n * @param a\n * @return\n */\nfunction rotate90cw(out, a) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = y;\n  out[1] = -x;\n  return out;\n}\n\n/**\n * Transform a point position to local frame.\n * @param out\n * @param worldPoint\n * @param framePosition\n * @param frameAngle\n * @return\n */\nfunction toLocalFrame(out, worldPoint, framePosition, frameAngle) {\n  const c = Math.cos(-frameAngle),\n    s = Math.sin(-frameAngle),\n    x = worldPoint[0] - framePosition[0],\n    y = worldPoint[1] - framePosition[1];\n  out[0] = c * x - s * y;\n  out[1] = s * x + c * y;\n  return out;\n}\n\n/**\n * Transform a point position to global frame.\n * @param out\n * @param localPoint\n * @param framePosition\n * @param frameAngle\n */\nfunction toGlobalFrame(out, localPoint, framePosition, frameAngle) {\n  const c = Math.cos(frameAngle),\n    s = Math.sin(frameAngle),\n    x = localPoint[0],\n    y = localPoint[1],\n    addX = framePosition[0],\n    addY = framePosition[1];\n  out[0] = c * x - s * y + addX;\n  out[1] = s * x + c * y + addY;\n}\n\n/**\n * Transform a vector to local frame.\n * @param out\n * @param worldVector\n * @param frameAngle\n * @return\n */\nfunction vectorToLocalFrame(out, worldVector, frameAngle) {\n  const c = Math.cos(-frameAngle),\n    s = Math.sin(-frameAngle),\n    x = worldVector[0],\n    y = worldVector[1];\n  out[0] = c * x - s * y;\n  out[1] = s * x + c * y;\n  return out;\n}\n\n/**\n * Transform a vector to global frame.\n */\nconst vectorToGlobalFrame = rotate;\n\n/**\n * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php\n * @param out\n * @param a\n * @param b\n * @param c\n * @return The \"out\" vector.\n */\nfunction centroid(out, a, b, c) {\n  add(out, a, b);\n  add(out, out, c);\n  scale(out, out, 1 / 3);\n  return out;\n}\n\n/**\n * Creates a new, empty vec2\n * @return a new 2D vector\n */\nfunction create() {\n  const out = new ARRAY_TYPE(2);\n  out[0] = 0;\n  out[1] = 0;\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n * @param a vector to clone\n * @return a new 2D vector\n */\nfunction clone(a) {\n  const out = new ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n * @param x X component\n * @param y Y component\n * @return a new 2D vector\n */\nfunction fromValues(x, y) {\n  const out = new ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n * @param out the receiving vector\n * @param a the source vector\n * @return out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n * @param out the receiving vector\n * @param x X component\n * @param y Y component\n * @return out\n */\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @return out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts two vec2's\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @return out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @return out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @return out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n * @param out the receiving vector\n * @param a the vector to scale\n * @param b amount to scale the vector by\n * @return out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n * @param a the first operand\n * @param b the second operand\n * @return distance between a and b\n */\nfunction distance(a, b) {\n  const x = b[0] - a[0];\n  const y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n * @param a the first operand\n * @param b the second operand\n * @return squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  const x = b[0] - a[0];\n  const y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n * @param a vector to calculate length of\n * @return length of a\n */\nfunction length(a) {\n  const x = a[0];\n  const y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n * @param a vector to calculate squared length of\n * @return squared length of a\n */\nfunction squaredLength(a) {\n  const x = a[0];\n  const y = a[1];\n  return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n * @param out the receiving vector\n * @param a vector to negate\n * @return out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n * @param out the receiving vector\n * @param a vector to normalize\n * @return out\n */\nfunction normalize(out, a) {\n  const x = a[0];\n  const y = a[1];\n  let len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n  }\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n * @param a the first operand\n * @param b the second operand\n * @return dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Returns a string representation of a vector\n * @param vec vector to represent as a string\n * @return string representation of the vector\n */\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n\n/**\n * Linearly interpolate/mix two vectors.\n * @param out\n * @param a First vector\n * @param b Second vector\n * @param t Lerp factor\n */\nfunction lerp(out, a, b, t) {\n  const ax = a[0];\n  const ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Reflect a vector along a normal.\n * @param out\n * @param vector\n * @param normal\n */\nfunction reflect(out, vector, normal) {\n  const dot = vector[0] * normal[0] + vector[1] * normal[1];\n  out[0] = vector[0] - 2 * normal[0] * dot;\n  out[1] = vector[1] - 2 * normal[1] * dot;\n  return out;\n}\n\n/**\n * Get the intersection point between two line segments.\n * @param out\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @return True if there was an intersection, otherwise false.\n */\nfunction getLineSegmentsIntersection(out, p0, p1, p2, p3) {\n  const t = getLineSegmentsIntersectionFraction(p0, p1, p2, p3);\n  if (t < 0) {\n    return false;\n  } else {\n    out[0] = p0[0] + t * (p1[0] - p0[0]);\n    out[1] = p0[1] + t * (p1[1] - p0[1]);\n    return true;\n  }\n}\n\n/**\n * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @return A number between 0 and 1 if there was an intersection, otherwise -1.\n */\nfunction getLineSegmentsIntersectionFraction(p0, p1, p2, p3) {\n  const s1_x = p1[0] - p0[0];\n  const s1_y = p1[1] - p0[1];\n  const s2_x = p3[0] - p2[0];\n  const s2_y = p3[1] - p2[1];\n  const s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n  const t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n    // Collision detected\n    return t;\n  }\n  return -1; // No collision\n}\n\nvar vec2 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add,\n    centroid: centroid,\n    clone: clone,\n    copy: copy,\n    create: create,\n    crossLength: crossLength,\n    crossVZ: crossVZ,\n    crossZV: crossZV,\n    distance: distance,\n    divide: divide,\n    dot: dot,\n    fromValues: fromValues,\n    getLineSegmentsIntersection: getLineSegmentsIntersection,\n    getLineSegmentsIntersectionFraction: getLineSegmentsIntersectionFraction,\n    length: length,\n    lerp: lerp,\n    multiply: multiply,\n    negate: negate,\n    normalize: normalize,\n    reflect: reflect,\n    rotate: rotate,\n    rotate90cw: rotate90cw,\n    scale: scale,\n    set: set,\n    squaredDistance: squaredDistance,\n    squaredLength: squaredLength,\n    str: str,\n    subtract: subtract,\n    toGlobalFrame: toGlobalFrame,\n    toLocalFrame: toLocalFrame,\n    vectorToGlobalFrame: vectorToGlobalFrame,\n    vectorToLocalFrame: vectorToLocalFrame\n});\n\n/**\n * Axis aligned bounding box class\n *\n * @example\n *     var aabb = new AABB({\n *         upperBound: [1, 1],\n *         lowerBound: [-1, -1]\n *     });\n */\nclass AABB {\n  /**\n   * The upper bound of the bounding box.\n   */\n\n  /**\n   * The lower bound of the bounding box.\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.lowerBound = options.lowerBound ? clone(options.lowerBound) : create();\n    this.upperBound = options.upperBound ? clone(options.upperBound) : create();\n  }\n\n  /**\n   * Set the AABB bounds from a set of points, transformed by the given position and angle.\n   * @param points An array of vec2's.\n   * @param position\n   * @param angle\n   * @param skinSize Some margin to be added to the AABB.\n   */\n  setFromPoints(points, position, angle, skinSize) {\n    if (angle === void 0) {\n      angle = 0;\n    }\n    if (skinSize === void 0) {\n      skinSize = 0;\n    }\n    const l = this.lowerBound;\n    const u = this.upperBound;\n\n    // Set to the first point\n    if (angle !== 0) {\n      rotate(l, points[0], angle);\n    } else {\n      copy(l, points[0]);\n    }\n    copy(u, l);\n\n    // Compute cosines and sines just once\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    for (let i = 1; i < points.length; i++) {\n      let p = points[i];\n      if (angle !== 0) {\n        const x = p[0],\n          y = p[1];\n        tmp$1[0] = cosAngle * x - sinAngle * y;\n        tmp$1[1] = sinAngle * x + cosAngle * y;\n        p = tmp$1;\n      }\n      for (let j = 0; j < 2; j++) {\n        if (p[j] > u[j]) {\n          u[j] = p[j];\n        }\n        if (p[j] < l[j]) {\n          l[j] = p[j];\n        }\n      }\n    }\n\n    // Add offset\n    if (position) {\n      add(l, l, position);\n      add(u, u, position);\n    }\n    if (skinSize) {\n      l[0] -= skinSize;\n      l[1] -= skinSize;\n      u[0] += skinSize;\n      u[1] += skinSize;\n    }\n  }\n\n  /**\n   * Copy bounds from an AABB to this AABB\n   * @param  {AABB} aabb\n   */\n  copy(aabb) {\n    copy(this.lowerBound, aabb.lowerBound);\n    copy(this.upperBound, aabb.upperBound);\n  }\n\n  /**\n   * Extend this AABB so that it covers the given AABB too.\n   * @param aabb\n   */\n  extend(aabb) {\n    const lower = this.lowerBound,\n      upper = this.upperBound;\n\n    // Loop over x and y\n    let i = 2;\n    while (i--) {\n      // Extend lower bound\n      const l = aabb.lowerBound[i];\n      if (lower[i] > l) {\n        lower[i] = l;\n      }\n\n      // Upper\n      const u = aabb.upperBound[i];\n      if (upper[i] < u) {\n        upper[i] = u;\n      }\n    }\n  }\n\n  /**\n   * Returns true if the given AABB overlaps this AABB.\n   * @param aabb\n   * @return\n   */\n  overlaps(aabb) {\n    const l1 = this.lowerBound,\n      u1 = this.upperBound,\n      l2 = aabb.lowerBound,\n      u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return (l2[0] <= u1[0] && u1[0] <= u2[0] || l1[0] <= u2[0] && u2[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u2[1] || l1[1] <= u2[1] && u2[1] <= u1[1]);\n  }\n\n  /**\n   * Whether the AABB contains a given point\n   * @param point\n   * @return\n   */\n  containsPoint(point) {\n    const l = this.lowerBound,\n      u = this.upperBound;\n    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];\n  }\n\n  /**\n   * Check if the AABB is hit by a ray.\n   * @param ray\n   * @return -1 if no hit, a number between 0 and 1 if hit, indicating the position between the \"from\" and \"to\" points.\n   * @example\n   *     var aabb = new AABB({\n   *         upperBound: [1, 1],\n   *         lowerBound: [-1, -1]\n   *     });\n   *     var ray = new Ray({\n   *         from: [-2, 0],\n   *         to: [0, 0]\n   *     });\n   *     var fraction = aabb.overlapsRay(ray); // fraction == 0.5\n   */\n  overlapsRay(ray) {\n    // ray.direction is unit direction vector of ray\n    const dirFracX = 1 / ray.direction[0];\n    const dirFracY = 1 / ray.direction[1];\n\n    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    const from = ray.from;\n    const lowerBound = this.lowerBound;\n    const upperBound = this.upperBound;\n    const t1 = (lowerBound[0] - from[0]) * dirFracX;\n    const t2 = (upperBound[0] - from[0]) * dirFracX;\n    const t3 = (lowerBound[1] - from[1]) * dirFracY;\n    const t4 = (upperBound[1] - from[1]) * dirFracY;\n    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));\n    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));\n\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behind us\n    if (tmax < 0) {\n      //t = tmax;\n      return -1;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax) {\n      //t = tmax;\n      return -1;\n    }\n    return tmin / ray.length;\n  }\n}\nconst tmp$1 = create();\n\nconst tmpPoint1 = [0, 0];\nconst tmpPoint2 = [0, 0];\nconst tmpLine1 = [[0, 0], [0, 0]];\nconst tmpLine2 = [[0, 0], [0, 0]];\n\n/**\n * Compute the intersection between two lines.\n * @param l1 Line vector 1\n * @param l2 Line vector 2\n * @param precision Precision to use when checking if the lines are parallel\n * @return The intersection point.\n */\nfunction lineInt(l1, l2, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  precision = precision || 0;\n  const i = [0, 0]; // point\n  const a1 = l1[1][1] - l1[0][1];\n  const b1 = l1[0][0] - l1[1][0];\n  const c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  const a2 = l2[1][1] - l2[0][1];\n  const b2 = l2[0][0] - l2[1][0];\n  const c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  const det = a1 * b2 - a2 * b1;\n  if (!scalarsEqual(det, 0, precision)) {\n    // lines are not parallel\n    i[0] = (b2 * c1 - b1 * c2) / det;\n    i[1] = (a1 * c2 - a2 * c1) / det;\n  }\n  return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @param p1 The start vertex of the first line segment.\n * @param p2 The end vertex of the first line segment.\n * @param q1 The start vertex of the second line segment.\n * @param q2 The end vertex of the second line segment.\n * @return True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2) {\n  const dx = p2[0] - p1[0];\n  const dy = p2[1] - p1[1];\n  const da = q2[0] - q1[0];\n  const db = q2[1] - q1[1];\n\n  // segments are parallel\n  if (da * dy - db * dx === 0) {\n    return false;\n  }\n  const s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n  const t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @param a point 1\n * @param b point 2\n * @param c point 3\n * @return the area of a triangle spanned by the three given points\n */\nfunction triangleArea(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction isLeft(a, b, c) {\n  return triangleArea(a, b, c) > 0;\n}\nfunction isLeftOn(a, b, c) {\n  return triangleArea(a, b, c) >= 0;\n}\nfunction isRight(a, b, c) {\n  return triangleArea(a, b, c) < 0;\n}\nfunction isRightOn(a, b, c) {\n  return triangleArea(a, b, c) <= 0;\n}\n\n/**\n * Check if three points are collinear\n * @param a point 1\n * @param b point 2\n * @param c point 3\n * @param thresholdAngle angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return whether the points are collinear\n */\nfunction collinear(a, b, c, thresholdAngle) {\n  if (thresholdAngle === void 0) {\n    thresholdAngle = 0;\n  }\n  if (!thresholdAngle) {\n    return triangleArea(a, b, c) === 0;\n  } else {\n    const ab = tmpPoint1;\n    const bc = tmpPoint2;\n    ab[0] = b[0] - a[0];\n    ab[1] = b[1] - a[1];\n    bc[0] = c[0] - b[0];\n    bc[1] = c[1] - b[1];\n    const dot = ab[0] * bc[0] + ab[1] * bc[1];\n    const magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]);\n    const magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]);\n    const angle = Math.acos(dot / (magA * magB));\n    return angle < thresholdAngle;\n  }\n}\nfunction sqdist(a, b) {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @param i vertex position\n * @return vertex at position i\n */\nfunction polygonAt(polygon, i) {\n  const s = polygon.length;\n  return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n */\nfunction polygonClear(polygon) {\n  polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\" -1 from an other polygon \"poly\" onto this one.\n * @param polygon the polygon to append to\n * @param poly The polygon to get points from.\n * @param from The vertex index in \"poly\".\n * @param to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n */\nfunction polygonAppend(polygon, poly, from, to) {\n  for (let i = from; i < to; i++) {\n    polygon.push(poly[i]);\n  }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n */\nfunction makeCCW(polygon) {\n  let br = 0;\n  const v = polygon;\n\n  // find bottom right point\n  for (let i = 1; i < polygon.length; ++i) {\n    if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n      br = i;\n    }\n  }\n\n  // reverse poly if clockwise\n  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n    polygonReverse(polygon);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Reverse the vertices in the polygon\n */\nfunction polygonReverse(polygon) {\n  const tmp = [];\n  const N = polygon.length;\n  for (let i = 0; i !== N; i++) {\n    tmp.push(polygon.pop());\n  }\n  for (let i = 0; i !== N; i++) {\n    polygon[i] = tmp[i];\n  }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @param i the point in the polygon to check\n * @return whether the given point in the polygon is a reflex point\n */\nfunction polygonIsReflex(polygon, i) {\n  return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @param a vertex index 1\n * @param b vertex index 2\n * @return whether two vertices in the polygon can see each other\n */\nfunction polygonCanSee(polygon, a, b) {\n  const l1 = tmpLine1;\n  const l2 = tmpLine2;\n  if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n    return false;\n  }\n  const dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n  for (let i = 0; i !== polygon.length; ++i) {\n    // for each edge\n    if ((i + 1) % polygon.length === a || i === a) {\n      // ignore incident edges\n      continue;\n    }\n    if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n      // if diag intersects an edge\n      l1[0] = polygonAt(polygon, a);\n      l1[1] = polygonAt(polygon, b);\n      l2[0] = polygonAt(polygon, i);\n      l2[1] = polygonAt(polygon, i + 1);\n      const p = lineInt(l1, l2);\n      if (sqdist(polygonAt(polygon, a), p) < dist) {\n        // if edge is blocking visibility to b\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @param a vertex index 1\n * @param b vertex index 2\n * @return if two vertices in the polygon can see each other\n */\nfunction polygonCanSee2(polygon, a, b) {\n  // for each edge\n  for (let i = 0; i !== polygon.length; ++i) {\n    // ignore incident edges\n    if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n      continue;\n    }\n    if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @param i the start vertex to copy from\n * @param j the end vertex to copy from\n * @param targetPoly optional target polygon to save in.\n * @return the resulting copy.\n */\nfunction polygonCopy(polygon, i, j, targetPoly) {\n  if (targetPoly === void 0) {\n    targetPoly = [];\n  }\n  polygonClear(targetPoly);\n  if (i < j) {\n    // Insert all vertices from i to j\n    for (let k = i; k <= j; k++) {\n      targetPoly.push(polygon[k]);\n    }\n  } else {\n    // Insert vertices 0 to j\n    for (let k = 0; k <= j; k++) {\n      targetPoly.push(polygon[k]);\n    }\n\n    // Insert vertices i to end\n    for (let k = i; k < polygon.length; k++) {\n      targetPoly.push(polygon[k]);\n    }\n  }\n  return targetPoly;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @return a list of edges that cuts the polygon\n */\nfunction getCutEdges(polygon) {\n  let min = [];\n  let tmp1;\n  let tmp2;\n  const tmpPoly = [];\n  let nDiags = Number.MAX_VALUE;\n  for (let i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(polygon, i)) {\n      for (let j = 0; j < polygon.length; ++j) {\n        if (polygonCanSee(polygon, i, j)) {\n          tmp1 = getCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n          tmp2 = getCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n          for (let k = 0; k < tmp2.length; k++) {\n            tmp1.push(tmp2[k]);\n          }\n          if (tmp1.length < nDiags) {\n            min = tmp1;\n            nDiags = tmp1.length;\n            min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n          }\n        }\n      }\n    }\n  }\n  return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @return An array of Polygon objects, or false if decomposition fails\n */\nfunction decomp(polygon) {\n  const edges = getCutEdges(polygon);\n  if (edges.length > 0) {\n    return slicePolygon(polygon, edges);\n  } else {\n    return [polygon];\n  }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @param cutEdges A list of edges, as returned by .getCutEdges()\n * @return the sliced polygons, or false if the operation was unsuccessful\n */\nfunction slicePolygon(polygon, cutEdges) {\n  if (cutEdges.length === 0) {\n    return [polygon];\n  }\n\n  // if given multiple edges\n  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n    const polys = [polygon];\n    for (let i = 0; i < cutEdges.length; i++) {\n      const cutEdge = cutEdges[i];\n      // Cut all polys\n      for (let j = 0; j < polys.length; j++) {\n        const poly = polys[j];\n        const result = slicePolygon(poly, cutEdge);\n        if (result) {\n          // Found poly! Cut and quit\n          polys.splice(j, 1);\n          polys.push(result[0], result[1]);\n          break;\n        }\n      }\n    }\n    return polys;\n  } else {\n    // Was given one edge\n    const cutEdge = cutEdges;\n    const i = polygon.indexOf(cutEdge[0]);\n    const j = polygon.indexOf(cutEdge[1]);\n    if (i !== -1 && j !== -1) {\n      return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @param polygon An array of vertices e.g. [[0,0],[0,1],...]\n * @return whether line segments of this polygon do not intersect each other.\n * @todo Should it check all segments with all others?\n */\nfunction isSimple(polygon) {\n  const path = polygon;\n  let i;\n\n  // Check\n  for (i = 0; i < path.length - 1; i++) {\n    for (let j = 0; j < i - 1; j++) {\n      if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n        return false;\n      }\n    }\n  }\n\n  // Check the segment between the last and the first point to all others\n  for (i = 1; i < path.length - 2; i++) {\n    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n  if (delta === void 0) {\n    delta = 0;\n  }\n  const a1 = p2[1] - p1[1];\n  const b1 = p1[0] - p2[0];\n  const c1 = a1 * p1[0] + b1 * p1[1];\n  const a2 = q2[1] - q1[1];\n  const b2 = q1[0] - q2[0];\n  const c2 = a2 * q1[0] + b2 * q1[1];\n  const det = a1 * b2 - a2 * b1;\n  if (!scalarsEqual(det, 0, delta)) {\n    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];\n  } else {\n    return [0, 0];\n  }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @param polygon the polygon to decompose\n * @param result\n * @param reflexVertices\n * @param steinerPoints\n * @param delta\n * @param maxlevel\n * @param level\n * @return the decomposed sub-polygons\n */\nfunction quickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n  if (result === void 0) {\n    result = [];\n  }\n  if (reflexVertices === void 0) {\n    reflexVertices = [];\n  }\n  if (steinerPoints === void 0) {\n    steinerPoints = [];\n  }\n  if (delta === void 0) {\n    delta = 25;\n  }\n  if (maxlevel === void 0) {\n    maxlevel = 100;\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  // Points\n  let upperInt = [0, 0];\n  let lowerInt = [0, 0];\n  let p = [0, 0];\n\n  // scalars\n  let upperDist = 0;\n  let lowerDist = 0;\n  let d = 0;\n  let closestDist = 0;\n\n  // Integers\n  let upperIndex = 0;\n  let lowerIndex = 0;\n  let closestIndex = 0;\n\n  // polygons\n  const lowerPoly = [];\n  const upperPoly = [];\n  const poly = polygon;\n  const v = polygon;\n  if (v.length < 3) {\n    return result;\n  }\n  level++;\n  if (level > maxlevel) {\n    console.warn('quickDecomp: max level (' + maxlevel + ') reached.');\n    return result;\n  }\n  for (let i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(poly, i)) {\n      reflexVertices.push(poly[i]);\n      upperDist = lowerDist = Number.MAX_VALUE;\n      for (let j = 0; j < polygon.length; ++j) {\n        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n          // if line intersects with an edge\n          p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n          if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n            // make sure it's inside the poly\n            d = sqdist(poly[i], p);\n            if (d < lowerDist) {\n              // keep only the closest intersection\n              lowerDist = d;\n              lowerInt = p;\n              lowerIndex = j;\n            }\n          }\n        }\n        if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n          p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n            d = sqdist(poly[i], p);\n            if (d < upperDist) {\n              upperDist = d;\n              upperInt = p;\n              upperIndex = j;\n            }\n          }\n        }\n      }\n\n      // if there are no vertices to connect to, choose a point in the middle\n      if (lowerIndex === (upperIndex + 1) % polygon.length) {\n        p[0] = (lowerInt[0] + upperInt[0]) / 2;\n        p[1] = (lowerInt[1] + upperInt[1]) / 2;\n        steinerPoints.push(p);\n        if (i < upperIndex) {\n          polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          if (lowerIndex !== 0) {\n            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n          }\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, poly.length);\n          }\n          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n        }\n      } else {\n        // connect to the closest point within the triangle\n        if (lowerIndex > upperIndex) {\n          upperIndex += polygon.length;\n        }\n        closestDist = Number.MAX_VALUE;\n        if (upperIndex < lowerIndex) {\n          return result;\n        }\n        for (let j = lowerIndex; j <= upperIndex; ++j) {\n          if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n              closestDist = d;\n              closestIndex = j % polygon.length;\n            }\n          }\n        }\n        if (i < closestIndex) {\n          polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n          if (closestIndex !== 0) {\n            polygonAppend(upperPoly, poly, closestIndex, v.length);\n          }\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, v.length);\n          }\n          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n          polygonAppend(upperPoly, poly, closestIndex, i + 1);\n        }\n      }\n\n      // solve smallest poly first\n      if (lowerPoly.length < upperPoly.length) {\n        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      } else {\n        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      }\n      return result;\n    }\n  }\n  result.push(polygon);\n  return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @param thresholdAngle The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return The number of points removed\n */\nfunction removeCollinearPoints(polygon, thresholdAngle) {\n  if (thresholdAngle === void 0) {\n    thresholdAngle = 0;\n  }\n  let num = 0;\n  for (let i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {\n    if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), thresholdAngle)) {\n      // Remove the middle point\n      polygon.splice(i % polygon.length, 1);\n      num++;\n    }\n  }\n  return num;\n}\n\n/**\n * Check if two scalars are equal\n * @param a scalar a\n * @param b scalar b\n * @param precision the precision for the equality check\n * @return whether the two scalars are equal with the given precision\n */\nfunction scalarsEqual(a, b, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  precision = precision || 0;\n  return Math.abs(a - b) <= precision;\n}\n\n/**\n * A line with a start and end point that is used to intersect shapes.\n * @see {@link World.raycast} for example usage\n */\nclass Ray {\n  /**\n   * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.\n   */\n  static CLOSEST = 1;\n\n  /**\n   * This raycasting mode will make the Ray stop when it finds the first intersection point.\n   */\n  static ANY = 2;\n\n  /**\n   * This raycasting mode will traverse all intersection points and executes a callback for each one.\n   */\n  static ALL = 4;\n\n  /**\n   * Ray start point.\n   */\n\n  /**\n   * Ray end point\n   */\n\n  /**\n   * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n   */\n\n  /**\n   * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n   */\n\n  /**\n   * Collision mask.\n   * @default -1\n   */\n\n  /**\n   * Collision group.\n   * @default -1\n   */\n\n  /**\n   * The intersection mode.\n   */\n\n  /**\n   * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n   */\n\n  /**\n   * The direction of the ray\n   */\n  direction = create();\n\n  /**\n   * Length of the ray\n   */\n  length = 1;\n  _currentBody = null;\n  _currentShape = null;\n\n  /**\n   * Constructor for a new Ray\n   * @param options\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.from = options.from ? clone(options.from) : create();\n    this.to = options.to ? clone(options.to) : create();\n    this.checkCollisionResponse = options.checkCollisionResponse ?? true;\n    this.skipBackfaces = !!options.skipBackfaces;\n    this.collisionMask = options.collisionMask ?? -1;\n    this.collisionGroup = options.collisionGroup ?? -1;\n    this.mode = options.mode ?? Ray.ANY;\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    this.callback = options?.callback || function /*result*/ () {};\n    this.update();\n  }\n\n  /**\n   * Should be called if you change the from or to point.\n   */\n  update() {\n    // Update .direction and .length\n    const d = this.direction;\n    subtract(d, this.to, this.from);\n    this.length = length(d);\n    normalize(d, d);\n  }\n\n  /**\n   * @param bodies An array of Body objects.\n   */\n  intersectBodies(result, bodies) {\n    for (let i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {\n      const body = bodies[i];\n      const aabb = body.getAABB();\n      if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {\n        this.intersectBody(result, body);\n      }\n    }\n  }\n\n  /**\n   * Shoot a ray at a body, get back information about the hit.\n   * @param body\n   */\n  intersectBody(result, body) {\n    const checkCollisionResponse = this.checkCollisionResponse;\n    if (checkCollisionResponse && !body.collisionResponse) {\n      return;\n    }\n    const worldPosition = intersectBody_worldPosition;\n    for (let i = 0, N = body.shapes.length; i < N; i++) {\n      const shape = body.shapes[i];\n      if (checkCollisionResponse && !shape.collisionResponse) {\n        continue; // Skip\n      }\n\n      if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {\n        continue;\n      }\n\n      // Get world angle and position of the shape\n      rotate(worldPosition, shape.position, body.angle);\n      add(worldPosition, worldPosition, body.position);\n      const worldAngle = shape.angle + body.angle;\n      this.intersectShape(result, shape, worldAngle, worldPosition, body);\n      if (result.shouldStop(this)) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Shoot a ray at a shape, get back information about the hit\n   * @param shape\n   * @param angle\n   * @param position\n   * @param body\n   */\n  intersectShape(result, shape, angle, position, body) {\n    const from = this.from;\n\n    // Checking radius\n    const distance = distanceFromIntersectionSquared(from, this.direction, position);\n    if (distance > shape.boundingRadius * shape.boundingRadius) {\n      return;\n    }\n    this._currentBody = body;\n    this._currentShape = shape;\n    shape.raycast(result, this, position, angle);\n    this._currentBody = this._currentShape = null;\n  }\n\n  /**\n   * Get the AABB of the ray.\n   * @param aabb\n   */\n  getAABB(result) {\n    const to = this.to;\n    const from = this.from;\n    set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));\n    set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));\n  }\n\n  /**\n   * @param fraction\n   * @param normal\n   * @param faceIndex\n   */\n  reportIntersection(result, fraction, normal, faceIndex) {\n    if (faceIndex === void 0) {\n      faceIndex = -1;\n    }\n    const shape = this._currentShape;\n    const body = this._currentBody;\n\n    // Skip back faces?\n    if (this.skipBackfaces && dot(normal, this.direction) > 0) {\n      return;\n    }\n    switch (this.mode) {\n      case Ray.ALL:\n        result.set(normal, shape, body, fraction, faceIndex);\n        this.callback(result);\n        break;\n      case Ray.CLOSEST:\n        // Store if closer than current closest\n        if (fraction < result.fraction || !result.hasHit()) {\n          result.set(normal, shape, body, fraction, faceIndex);\n        }\n        break;\n      case Ray.ANY:\n        // Report and stop.\n        result.set(normal, shape, body, fraction, faceIndex);\n        break;\n    }\n  }\n}\nconst v0 = create();\nconst intersect = create();\nfunction distanceFromIntersectionSquared(from, direction, position) {\n  // v0 is vector from from to position\n  subtract(v0, position, from);\n  const dot$1 = dot(v0, direction);\n\n  // intersect = direction * dot + from\n  scale(intersect, direction, dot$1);\n  add(intersect, intersect, from);\n  return squaredDistance(position, intersect);\n}\nconst intersectBody_worldPosition = create();\n\n/**\n * Storage for Ray casting hit data.\n */\nclass RaycastResult {\n  /**\n   * The normal of the hit, oriented in world space.\n   */\n\n  /**\n   * The hit shape, or null.\n   */\n\n  /**\n   * The hit body, or null.\n   */\n\n  /**\n   * The index of the hit triangle, if the hit shape was indexable.\n   * @default -1\n   */\n\n  /**\n   * Distance to the hit, as a fraction. 0 is at the \"from\" point, 1 is at the \"to\" point. Will be set to -1 if there was no hit yet.\n   * @default -1\n   */\n\n  /**\n   * If the ray should stop traversing.\n   */\n\n  constructor() {\n    this.normal = create();\n    this.shape = null;\n    this.body = null;\n    this.faceIndex = -1;\n    this.fraction = -1;\n    this.isStopped = false;\n  }\n\n  /**\n   * Reset all result data. Must be done before re-using the result object.\n   */\n  reset() {\n    set(this.normal, 0, 0);\n    this.shape = null;\n    this.body = null;\n    this.faceIndex = -1;\n    this.fraction = -1;\n    this.isStopped = false;\n  }\n\n  /**\n   * Get the distance to the hit point.\n   * @param ray\n   * @return\n   */\n  getHitDistance(ray) {\n    return distance(ray.from, ray.to) * this.fraction;\n  }\n\n  /**\n   * Returns true if the ray hit something since the last reset().\n   * @return\n   */\n  hasHit() {\n    return this.fraction !== -1;\n  }\n\n  /**\n   * Get world hit point.\n   * @param out\n   * @param ray\n   */\n  getHitPoint(out, ray) {\n    return lerp(out, ray.from, ray.to, this.fraction);\n  }\n\n  /**\n   * Can be called while iterating over hits to stop searching for hit points.\n   */\n  stop() {\n    this.isStopped = true;\n  }\n  shouldStop(ray) {\n    return this.isStopped || this.fraction !== -1 && ray.mode === Ray.ANY;\n  }\n  set(normal, shape, body, fraction, faceIndex) {\n    copy(this.normal, normal);\n    this.shape = shape;\n    this.body = body;\n    this.fraction = fraction;\n    this.faceIndex = faceIndex;\n  }\n}\n\n/**\n * Base class for objects that dispatches events.\n *\n * @example\n *     var emitter = new EventEmitter();\n *     emitter.on('myEvent', function(evt){\n *         console.log(evt.message);\n *     });\n *     emitter.emit({\n *         type: 'myEvent',\n *         message: 'Hello world!'\n *     });\n */\nclass EventEmitter {\n  listeners = {};\n\n  /**\n   * Add an event listener\n   * @param type\n   * @param listener\n   * @return The self object, for chainability.\n   * @example\n   *     emitter.on('myEvent', function(evt){\n   *         console.log('myEvt was triggered!');\n   *     });\n   */\n  on(type, listener) {\n    let listeners = this.listeners[type];\n    if (listeners === undefined) {\n      listeners = [];\n      this.listeners[type] = listeners;\n    }\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an event listener\n   * @param type\n   * @param listener\n   * @return The self object, for chainability.\n   * @example\n   *     emitter.on('myEvent', handler); // Add handler\n   *     emitter.off('myEvent', handler); // Remove handler\n   */\n  off(type, listener) {\n    const listeners = this.listeners[type];\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Check if an event listener is added\n   * @param type\n   * @param listener\n   * @return\n   */\n  has(type, listener) {\n    const listeners = this.listeners[type];\n    if (!listener) {\n      return listeners !== undefined;\n    }\n    return listeners !== undefined && listeners.indexOf(listener) !== -1;\n  }\n\n  /**\n   * Emit an event.\n   * @param event\n   * @param event.type\n   * @return The self object, for chainability.\n   * @example\n   *     emitter.emit({\n   *         type: 'myEvent',\n   *         customData: 123\n   *     });\n   */\n  emit(event) {\n    if (this.listeners === undefined) {\n      return this;\n    }\n    const eventListeners = this.listeners[event.type];\n    if (eventListeners !== undefined) {\n      // only emit to current listeners, ignore listeners that might be added inside a listener function\n      for (const listener of [...eventListeners]) {\n        listener(event);\n      }\n    }\n    return this;\n  }\n}\n\n/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nfunction triangulate(p) {\n  const n = p.length >> 1;\n  if (n < 3) return [];\n  const tgs = [];\n  const avl = [];\n  for (let i = 0; i < n; i++) avl.push(i);\n  let i = 0;\n  let al = n;\n  while (al > 3) {\n    const i0 = avl[(i + 0) % al];\n    const i1 = avl[(i + 1) % al];\n    const i2 = avl[(i + 2) % al];\n    const ax = p[2 * i0],\n      ay = p[2 * i0 + 1];\n    const bx = p[2 * i1],\n      by = p[2 * i1 + 1];\n    const cx = p[2 * i2],\n      cy = p[2 * i2 + 1];\n    let earFound = false;\n    if (convex(ax, ay, bx, by, cx, cy)) {\n      earFound = true;\n      for (let j = 0; j < al; j++) {\n        const vi = avl[j];\n        if (vi == i0 || vi == i1 || vi == i2) continue;\n        if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n          earFound = false;\n          break;\n        }\n      }\n    }\n    if (earFound) {\n      tgs.push(i0, i1, i2);\n      avl.splice((i + 1) % al, 1);\n      al--;\n      i = 0;\n    } else if (i++ > 3 * al) break; // no convex angles :(\n  }\n\n  tgs.push(avl[0], avl[1], avl[2]);\n  return tgs;\n}\nfunction pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {\n  const v0x = cx - ax;\n  const v0y = cy - ay;\n  const v1x = bx - ax;\n  const v1y = by - ay;\n  const v2x = px - ax;\n  const v2y = py - ay;\n  const dot00 = v0x * v0x + v0y * v0y;\n  const dot01 = v0x * v1x + v0y * v1y;\n  const dot02 = v0x * v2x + v0y * v2y;\n  const dot11 = v1x * v1x + v1y * v1y;\n  const dot12 = v1x * v2x + v1y * v2y;\n  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n  const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n  const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n  // Check if point is in triangle\n  return u >= 0 && v >= 0 && u + v < 1;\n}\nfunction convex(ax, ay, bx, by, cx, cy) {\n  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\n}\n\n/* eslint-disable @typescript-eslint/no-empty-function */\n\n/**\n * Base class for shapes. Not to be used directly.\n */\nclass Shape {\n  /**\n   * The body this shape is attached to. A shape can only be attached to a single body.\n   */\n  body = null;\n\n  /**\n   * Body-local position of the shape.\n   */\n  position = create();\n\n  /**\n   * Body-local angle of the shape.\n   */\n\n  /**\n   * The type of the shape. One of:\n   *\n   * <ul>\n   * <li><a href=\"Shape.html#property_CIRCLE\">Shape.CIRCLE</a></li>\n   * <li><a href=\"Shape.html#property_PARTICLE\">Shape.PARTICLE</a></li>\n   * <li><a href=\"Shape.html#property_PLANE\">Shape.PLANE</a></li>\n   * <li><a href=\"Shape.html#property_CONVEX\">Shape.CONVEX</a></li>\n   * <li><a href=\"Shape.html#property_LINE\">Shape.LINE</a></li>\n   * <li><a href=\"Shape.html#property_BOX\">Shape.BOX</a></li>\n   * <li><a href=\"Shape.html#property_CAPSULE\">Shape.CAPSULE</a></li>\n   * <li><a href=\"Shape.html#property_HEIGHTFIELD\">Shape.HEIGHTFIELD</a></li>\n   * </ul>\n   */\n\n  /**\n   * Shape object identifier\n   */\n\n  /**\n   * Bounding circle radius of this shape\n   */\n  boundingRadius = 0;\n\n  /**\n   * Collision group that this shape belongs to (bit mask). See <a href=\"http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/\">this tutorial</a>.\n   *\n   * @example\n   *     // Setup bits for each available group\n   *     var PLAYER = Math.pow(2,0),\n   *         ENEMY =  Math.pow(2,1),\n   *         GROUND = Math.pow(2,2)\n   *\n   *     // Put shapes into their groups\n   *     player1Shape.collisionGroup = PLAYER;\n   *     player2Shape.collisionGroup = PLAYER;\n   *     enemyShape  .collisionGroup = ENEMY;\n   *     groundShape .collisionGroup = GROUND;\n   *\n   *     // Assign groups that each shape collide with.\n   *     // Note that the players can collide with ground and enemies, but not with other players.\n   *     player1Shape.collisionMask = ENEMY | GROUND;\n   *     player2Shape.collisionMask = ENEMY | GROUND;\n   *     enemyShape  .collisionMask = PLAYER | GROUND;\n   *     groundShape .collisionMask = PLAYER | ENEMY;\n   *\n   * @example\n   *     // How collision check is done\n   *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){\n   *         // The shapes will collide\n   *     }\n   */\n\n  /**\n   * Whether to produce contact forces when in contact with other bodies.\n   * Note that contacts will be generated, but they will be disabled.\n   * That means that this shape will move through other body shapes, but it will still trigger contact events, etc.\n   */\n\n  /**\n   * Collision mask of this shape. See .collisionGroup.\n   */\n\n  /**\n   * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.\n   */\n\n  /**\n   * Area of this shape.\n   */\n  area = 0;\n\n  /**\n   * Set to true if you want this shape to be a sensor.\n   * A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.\n   */\n\n  /**\n   * ID counter for shapes\n   */\n  static idCounter = 0;\n\n  /**\n   * Circle shape type\n   */\n  static CIRCLE = 1;\n\n  /**\n   * Particle shape type\n   */\n  static PARTICLE = 2;\n\n  /**\n   * Plane shape type\n   */\n  static PLANE = 4;\n\n  /**\n   * Convex shape type\n   */\n  static CONVEX = 8;\n\n  /**\n   * Line shape type\n   */\n  static LINE = 16;\n\n  /**\n   * Box shape type\n   */\n  static BOX = 32;\n\n  /**\n   * Capsule shape type\n   */\n  static CAPSULE = 64;\n\n  /**\n   * Heightfield shape type\n   */\n  static HEIGHTFIELD = 128;\n\n  /**\n   * Constructor for a Shape\n   * @param options\n   */\n  constructor(options) {\n    this.id = Shape.idCounter++;\n    this.body = null;\n    if (options.position) {\n      copy(this.position, options.position);\n    }\n    this.type = options.type;\n    this.angle = options.angle ?? 0;\n    this.collisionGroup = options.collisionGroup ?? 1;\n    this.collisionResponse = options.collisionResponse ?? true;\n    this.collisionMask = options.collisionMask ?? 1;\n    this.sensor = options.sensor ?? false;\n    this.material = options.material ?? null;\n  }\n\n  /**\n   * Should return the moment of inertia around the Z axis of the body.\n   * See <a href=\"http://en.wikipedia.org/wiki/List_of_moments_of_inertia\">Wikipedia's list of moments of inertia</a>.\n   * @return If the inertia is infinity or if the object simply isn't possible to rotate, return 0.\n   */\n\n  /**\n   * Compute the world axis-aligned bounding box (AABB) of this shape.\n   * @param out The resulting AABB.\n   * @param position World position of the shape.\n   * @param angle World angle of the shape.\n   */\n\n  /**\n   * Updates the bounding circle radius of this shape.\n   */\n  updateBoundingRadius() {}\n\n  /**\n   * Update the .area property of the shape.\n   */\n  updateArea() {}\n\n  /**\n   * Perform raycasting on this shape.\n   * @param result Where to store the resulting data.\n   * @param ray The Ray that you want to use for raycasting.\n   * @param position World position of the shape (the .position property will be ignored).\n   * @param angle World angle of the shape (the .angle property will be ignored).\n   */\n  raycast(_result, _ray, _position, _angle) {}\n\n  /**\n   * Test if a point is inside this shape.\n   * @param _localPoint\n   * @return whether a point is inside this shape\n   */\n  pointTest(_localPoint) {\n    return false;\n  }\n\n  /**\n   * Transform a world point to local shape space (assumed the shape is transformed by both itself and the body).\n   * @param out\n   * @param worldPoint\n   */\n  worldPointToLocal(out, worldPoint) {\n    const body = this.body;\n    rotate(shapeWorldPosition, this.position, body.angle);\n    add(shapeWorldPosition, shapeWorldPosition, body.position);\n    toLocalFrame(out, worldPoint, shapeWorldPosition, this.body.angle + this.angle);\n    return out;\n  }\n}\nconst shapeWorldPosition = create();\n\n/**\n * Convex shape class.\n *\n * @example\n *     var body = new Body({ mass: 1 });\n *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];\n *     var convexShape = new Convex({\n *         vertices: vertices\n *     });\n *     body.addShape(convexShape);\n */\nclass Convex extends Shape {\n  /**\n   * Vertices defined in the local frame.\n   */\n\n  /**\n   * Axes\n   */\n\n  /**\n   * Edge normals defined in the local frame, pointing out of the shape.\n   */\n\n  /**\n   * The center of mass of the Convex\n   */\n\n  /**\n   * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n   */\n\n  /**\n   * The bounding radius of the convex\n   */\n\n  /**\n   * Constructor for Convex shape\n   * @param options\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const params = {\n      type: Shape.CONVEX,\n      vertices: [],\n      axes: [],\n      ...options\n    };\n    super(params);\n    this.axes = params.axes;\n\n    // Copy the verts\n    this.vertices = [];\n    for (let i = 0; i < params.vertices.length; i++) {\n      this.vertices.push(clone(params.vertices[i]));\n    }\n    this.normals = [];\n    for (let i = 0; i < params.vertices.length; i++) {\n      this.normals.push(create());\n    }\n    this.updateNormals();\n    this.centerOfMass = create();\n    this.triangles = [];\n    if (this.vertices.length) {\n      this.updateTriangles();\n      this.updateCenterOfMass();\n    }\n    this.boundingRadius = 0;\n    this.updateBoundingRadius();\n    this.updateArea();\n    if (this.area < 0) {\n      throw new Error('Convex vertices must be given in counter-clockwise winding.');\n    }\n  }\n  updateNormals() {\n    for (let i = 0; i < this.vertices.length; i++) {\n      const worldPoint0 = this.vertices[i];\n      const worldPoint1 = this.vertices[(i + 1) % this.vertices.length];\n      const normal = this.normals[i];\n      subtract(normal, worldPoint1, worldPoint0);\n\n      // Get normal - just rotate 90 degrees since vertices are given in CCW\n      rotate90cw(normal, normal);\n      normalize(normal, normal);\n    }\n  }\n\n  /**\n   * Project a Convex onto a world-oriented axis\n   * @param offset\n   * @param localAxis\n   * @param result\n   */\n  projectOntoLocalAxis(localAxis, result) {\n    let max = 0;\n    let min = 0;\n    localAxis = tmpVec1;\n\n    // Get projected position of all vertices\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      const value = dot(v, localAxis);\n      if (max === null || value > max) {\n        max = value;\n      }\n      if (min === null || value < min) {\n        min = value;\n      }\n    }\n    if (min > max) {\n      const t = min;\n      min = max;\n      max = t;\n    }\n    set(result, min, max);\n  }\n  projectOntoWorldAxis(localAxis, shapeOffset, shapeAngle, result) {\n    let worldAxis = tmpVec2;\n    this.projectOntoLocalAxis(localAxis, result);\n\n    // Project the position of the body onto the axis - need to add this to the result\n    if (shapeAngle !== 0) {\n      rotate(worldAxis, localAxis, shapeAngle);\n    } else {\n      worldAxis = localAxis;\n    }\n    const offset = dot(shapeOffset, worldAxis);\n    set(result, result[0] + offset, result[1] + offset);\n  }\n\n  /**\n   * Update the .triangles property\n   */\n  updateTriangles() {\n    this.triangles.length = 0;\n\n    // Rewrite on polyk notation, array of numbers\n    const polykVerts = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      polykVerts.push(v[0], v[1]);\n    }\n\n    // Triangulate\n    const triangles = triangulate(polykVerts);\n\n    // Loop over all triangles, add their inertia contributions to I\n    for (let i = 0; i < triangles.length; i += 3) {\n      const id1 = triangles[i],\n        id2 = triangles[i + 1],\n        id3 = triangles[i + 2];\n\n      // Add to triangles\n      this.triangles.push([id1, id2, id3]);\n    }\n  }\n\n  /**\n   * Update the .centerOfMass property.\n   */\n  updateCenterOfMass() {\n    const triangles = this.triangles,\n      verts = this.vertices,\n      cm = this.centerOfMass,\n      centroid$1 = updateCenterOfMass_centroid;\n    let a = updateCenterOfMass_a,\n      b = updateCenterOfMass_b,\n      c = updateCenterOfMass_c;\n    const centroid_times_mass = updateCenterOfMass_centroid_times_mass;\n    set(cm, 0, 0);\n    let totalArea = 0;\n    for (let i = 0; i !== triangles.length; i++) {\n      const t = triangles[i];\n      a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];\n      centroid(centroid$1, a, b, c);\n\n      // Get mass for the triangle (density=1 in this case)\n      // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n      const m = Convex.triangleArea(a, b, c);\n      totalArea += m;\n\n      // Add to center of mass\n      scale(centroid_times_mass, centroid$1, m);\n      add(cm, cm, centroid_times_mass);\n    }\n    scale(cm, cm, 1 / totalArea);\n  }\n\n  /**\n   * Compute the moment of inertia of the Convex.\n   * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n   */\n  computeMomentOfInertia() {\n    let denom = 0.0,\n      numer = 0.0;\n    const N = this.vertices.length;\n    for (let j = N - 1, i = 0; i < N; j = i, i++) {\n      const p0 = this.vertices[j];\n      const p1 = this.vertices[i];\n      const a = Math.abs(crossLength(p0, p1));\n      const b = dot(p1, p1) + dot(p1, p0) + dot(p0, p0);\n      denom += a * b;\n      numer += a;\n    }\n    return 1.0 / 6.0 * (denom / numer);\n  }\n\n  /**\n   * Updates the .boundingRadius property\n   */\n  updateBoundingRadius() {\n    const verts = this.vertices;\n    let r2 = 0;\n    for (let i = 0; i !== verts.length; i++) {\n      const l2 = squaredLength(verts[i]);\n      if (l2 > r2) {\n        r2 = l2;\n      }\n    }\n    this.boundingRadius = Math.sqrt(r2);\n  }\n\n  /**\n   * Update the .area\n   */\n  updateArea() {\n    this.updateTriangles();\n    this.area = 0;\n    const triangles = this.triangles,\n      verts = this.vertices;\n    for (let i = 0; i !== triangles.length; i++) {\n      const t = triangles[i],\n        a = verts[t[0]],\n        b = verts[t[1]],\n        c = verts[t[2]];\n\n      // Get mass for the triangle (density=1 in this case)\n      const m = Convex.triangleArea(a, b, c);\n      this.area += m;\n    }\n  }\n\n  // todo - approximate with a local AABB?\n  computeAABB(out, position, angle) {\n    out.setFromPoints(this.vertices, position, angle, 0);\n  }\n\n  /**\n   * raycast\n   * @param result\n   * @param ray\n   * @param position\n   * @param angle\n   */\n  raycast(result, ray, position, angle) {\n    const rayStart = intersectConvex_rayStart;\n    const rayEnd = intersectConvex_rayEnd;\n    const normal = intersectConvex_normal;\n    const vertices = this.vertices;\n\n    // Transform to local shape space\n    toLocalFrame(rayStart, ray.from, position, angle);\n    toLocalFrame(rayEnd, ray.to, position, angle);\n    const n = vertices.length;\n    for (let i = 0; i < n && !result.shouldStop(ray); i++) {\n      const q1 = vertices[i];\n      const q2 = vertices[(i + 1) % n];\n      const delta = getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);\n      if (delta >= 0) {\n        subtract(normal, q2, q1);\n        rotate(normal, normal, -Math.PI / 2 + angle);\n        normalize(normal, normal);\n        ray.reportIntersection(result, delta, normal, i);\n      }\n    }\n  }\n  pointTest(localPoint) {\n    const r0 = pic_r0,\n      r1 = pic_r1,\n      verts = this.vertices,\n      numVerts = verts.length;\n    let lastCross = null;\n    for (let i = 0; i < numVerts + 1; i++) {\n      const v0 = verts[i % numVerts],\n        v1 = verts[(i + 1) % numVerts];\n      subtract(r0, v0, localPoint);\n      subtract(r1, v1, localPoint);\n      const cross = crossLength(r0, r1);\n      if (lastCross === null) {\n        lastCross = cross;\n      }\n\n      // If we got a different sign of the distance vector, the point is out of the polygon\n      if (cross * lastCross < 0) {\n        return false;\n      }\n      lastCross = cross;\n    }\n    return true;\n  }\n\n  /**\n   * Get the area of the triangle spanned by the three points a, b, c.\n   * The area is positive if the points are given in counter-clockwise order, otherwise negative.\n   * @param a\n   * @param b\n   * @param c\n   * @return\n   */\n  static triangleArea(a, b, c) {\n    return ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) * 0.5;\n  }\n}\nconst tmpVec1 = create();\nconst tmpVec2 = create();\nconst updateCenterOfMass_centroid = create();\nconst updateCenterOfMass_centroid_times_mass = create();\nconst updateCenterOfMass_a = create();\nconst updateCenterOfMass_b = create();\nconst updateCenterOfMass_c = create();\nconst intersectConvex_rayStart = create();\nconst intersectConvex_rayEnd = create();\nconst intersectConvex_normal = create();\nconst pic_r0 = create();\nconst pic_r1 = create();\n\n/**\n * A rigid body. Has got a center of mass, position, velocity and a number of\n * shapes that are used for collisions.\n *\n * @example\n *     // Create a typical dynamic body\n *     var body = new Body({\n *         mass: 1, // non-zero mass will set type to Body.DYNAMIC\n *         position: [0, 5],\n *         angle: 0,\n *         velocity: [0, 0],\n *         angularVelocity: 0\n *     });\n *\n *     // Add a circular shape to the body\n *     var circleShape = new Circle({ radius: 0.5 });\n *     body.addShape(circleShape);\n *\n *     // Add the body to the world\n *     world.addBody(body);\n *\n * @example\n *     // Create a static plane body\n *     var planeBody = new Body({\n *         mass: 0, // zero mass will set type to Body.STATIC\n *         position: [0, 0]\n *     });\n *     var planeShape = new Plane();\n *     planeBody.addShape(planeShape);\n *     world.addBody(planeBody);\n *\n * @example\n *     // Create a moving kinematic box body\n *     var platformBody = new Body({\n *         type: Body.KINEMATIC,\n *         position: [0, 3],\n *         velocity: [1, 0]\n *     });\n *     var boxShape = new Box({ width: 2, height: 0.5 });\n *     platformBody.addShape(boxShape);\n *     world.addBody(platformBody);\n */\nclass Body extends EventEmitter {\n  /**\n   * Dynamic body.\n   */\n  static DYNAMIC = 1;\n\n  /**\n   * Static body.\n   */\n  static STATIC = 2;\n\n  /**\n   * Kinematic body.\n   */\n  static KINEMATIC = 4;\n\n  /**\n   * Awake sleep state.\n   */\n  static AWAKE = 0;\n\n  /**\n   * Sleepy sleep state.\n   */\n  static SLEEPY = 1;\n\n  /**\n   * Sleeping sleep state.\n   */\n  static SLEEPING = 2;\n\n  /**\n   * Id counter for Body instances\n   */\n  static _idCounter = 0;\n\n  /**\n   * The body identifier\n   */\n\n  /**\n   * Index of the body in the World .bodies array. Is set to -1 if the body isn't added to a World.\n   */\n\n  /**\n   * The world that this body is added to (read only). This property is set to NULL if the body is not added to any world.\n   */\n  world = null;\n\n  /**\n   * The shapes of the body.\n   */\n\n  /**\n   * The mass of the body. If you change this number, you should call {@link Body.updateMassProperties}.\n   *\n   * @example\n   *     body.mass = 1;\n   *     body.updateMassProperties();\n   */\n\n  /**\n   * The inverse mass of the body.\n   */\n\n  /**\n   * The inertia of the body around the Z axis.\n   */\n\n  /**\n   * The inverse inertia of the body.\n   */\n\n  /**\n   * Set to true if you want to fix the rotation of the body.\n   *\n   * @example\n   *     // Fix rotation during runtime\n   *     body.fixedRotation = true;\n   *     body.updateMassProperties();\n   */\n\n  /**\n   * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.\n   *\n   * @example\n   *     // Fix X movement on body creation\n   *     var body = new Body({ mass: 1, fixedX: true });\n   *\n   * @example\n   *     // Fix X movement during runtime\n   *     body.fixedX = true;\n   *     body.updateMassProperties();\n   */\n\n  /**\n   * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X. See .fixedX\n   */\n\n  /**\n   * The position of the body in the world. Don't use this for rendering, instead use .interpolatedPosition\n   */\n\n  /**\n   * The interpolated position of the body. Use this for rendering.\n   */\n\n  /**\n   * The previous position of the body.\n   */\n\n  /**\n   * The current velocity of the body.\n   */\n\n  /**\n   * Constraint velocity that was added to the body during the last step.\n   */\n\n  /**\n   * Angular constraint velocity that was added to the body during last step.\n   */\n\n  /**\n   * The angle of the body, in radians.\n   *\n   * @example\n   *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.\n   *     // If you need a value between 0 and 2*pi, use the following function to normalize it.\n   *     function normalizeAngle(angle){\n   *         angle = angle % (2*Math.PI);\n   *         if(angle < 0){\n   *             angle += (2*Math.PI);\n   *         }\n   *         return angle;\n   *     }\n   */\n\n  /**\n   * The previous angle of the body.\n   */\n\n  /**\n   * The interpolated angle of the body. Use this for rendering.\n   */\n\n  /**\n   * The angular velocity of the body, in radians per second.\n   */\n\n  /**\n   * The force acting on the body. Since the body force (and {@link Body.angularForce}) will be zeroed after each step, so you need to set the force before each step.\n   *\n   * @example\n   *     // This produces a forcefield of 1 Newton in the positive x direction.\n   *     for(var i=0; i<numSteps; i++){\n   *         body.force[0] = 1;\n   *         world.step(1/60);\n   *     }\n   *\n   * @example\n   *     // This will apply a rotational force on the body\n   *     for(var i=0; i<numSteps; i++){\n   *         body.angularForce = -3;\n   *         world.step(1/60);\n   *     }\n   */\n\n  /**\n   * The angular force acting on the body. See {@link Body.force}.\n   */\n\n  /**\n   * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.\n   * @default 0.1\n   */\n\n  /**\n   * The angular force acting on the body. Should be a value between 0 and 1.\n   * @default 0.1\n   */\n\n  /**\n   * The type of motion this body has. Should be one of: {@link Body.STATIC}, {@link Body.DYNAMIC} and {@link Body.KINEMATIC}.\n   *\n   * * Static bodies do not move, and they do not respond to forces or collision.\n   * * Dynamic bodies body can move and respond to collisions and forces.\n   * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.\n   *\n   * @example\n   *     // Bodies are static by default. Static bodies will never move.\n   *     var body = new Body();\n   *     console.log(body.type == Body.STATIC); // true\n   *\n   * @example\n   *     // By setting the mass of a body to a nonzero number, the body\n   *     // will become dynamic and will move and interact with other bodies.\n   *     var dynamicBody = new Body({\n   *         mass : 1\n   *     });\n   *     console.log(dynamicBody.type == Body.DYNAMIC); // true\n   *\n   * @example\n   *     // Kinematic bodies will only move if you change their velocity.\n   *     var kinematicBody = new Body({\n   *         type: Body.KINEMATIC // Type can be set via the options object.\n   *     });\n   */\n\n  /**\n   * Bounding circle radius. Update with {@link Body.updateBoundingRadius}.\n   */\n\n  /**\n   * Bounding box of this body. Update with {@link Body.updateAABB}.\n   */\n\n  /**\n   * Indicates if the AABB needs update. Update it with {@link \"Body.updateAABB\"}.\n   *\n   * @example\n   *     // Force update the AABB\n   *     body.aabbNeedsUpdate = true;\n   *     body.updateAABB();\n   *     console.log(body.aabbNeedsUpdate); // false\n   */\n\n  /**\n   * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {@link World} before anything will happen.\n   * @default true\n   */\n\n  /**\n   * One of {@link Body.AWAKE}, {@link Body.SLEEPY} and {@link Body.SLEEPING}.\n   *\n   * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).\n   *\n   * @default Body.AWAKE\n   */\n\n  /**\n   * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n   * @default 0.2\n   */\n\n  /**\n   * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n   * @default 1\n   */\n\n  /**\n   * Whether the body wants to sleep\n   */\n\n  /**\n   * The last time when the body went to SLEEPY state.\n   */\n\n  /**\n   * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.\n   * @default 1\n   */\n\n  /**\n   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.\n   */\n\n  /**\n   * How long the body has been sleeping.\n   */\n\n  /**\n   * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.\n   * @default -1\n   */\n\n  /**\n   * The number of iterations that should be used when searching for the time of impact during CCD.\n   * A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.\n   * @default 10\n   */\n\n  /**\n   * @internal\n   */\n\n  /**\n   * @internal\n   */\n\n  /**\n   * @internal\n   */\n\n  /**\n   * @internal\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super();\n    this.id = options.id || ++Body._idCounter;\n    this.index = -1;\n    this.shapes = [];\n    this.mass = options.mass || 0;\n    this.invMass = 0;\n    this.inertia = 0;\n    this.invInertia = 0;\n    this.invMassSolve = 0;\n    this.invInertiaSolve = 0;\n    this.fixedRotation = !!options.fixedRotation;\n    this.fixedX = !!options.fixedX;\n    this.fixedY = !!options.fixedY;\n    this.massMultiplier = create();\n    this.position = options.position ? clone(options.position) : create();\n    this.interpolatedPosition = clone(this.position);\n    this.previousPosition = clone(this.position);\n    this.velocity = options.velocity ? clone(options.velocity) : create();\n    this.vlambda = create();\n    this.wlambda = 0;\n    this.angle = options.angle || 0;\n    this.previousAngle = this.angle;\n    this.interpolatedAngle = this.angle;\n    this.angularVelocity = options.angularVelocity || 0;\n    this.force = options.force ? clone(options.force) : create();\n    this.angularForce = options.angularForce || 0;\n    this.damping = options.damping ?? 0.1;\n    this.angularDamping = options.angularDamping ?? 0.1;\n    this.type = Body.STATIC;\n    if (options.type !== undefined) {\n      this.type = options.type;\n    } else if (!options.mass) {\n      this.type = Body.STATIC;\n    } else {\n      this.type = Body.DYNAMIC;\n    }\n    this.boundingRadius = 0;\n    this.aabb = new AABB();\n    this.aabbNeedsUpdate = true;\n    this.allowSleep = options.allowSleep ?? true;\n    this.wantsToSleep = false;\n    this.sleepState = Body.AWAKE;\n    this.sleepSpeedLimit = options.sleepSpeedLimit ?? 0.2;\n    this.sleepTimeLimit = options.sleepTimeLimit ?? 1;\n    this.idleTime = 0;\n    this.timeLastSleepy = 0;\n    this.collisionResponse = options.collisionResponse ?? true;\n    this.ccdSpeedThreshold = options.ccdSpeedThreshold ?? -1;\n    this.ccdIterations = options.ccdIterations ?? 10;\n    this.gravityScale = options.gravityScale ?? 1;\n    this.islandId = -1;\n    this.concavePath = null;\n    this._wakeUpAfterNarrowphase = false;\n    this.updateMassProperties();\n  }\n  updateSolveMassProperties() {\n    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {\n      this.invMassSolve = 0;\n      this.invInertiaSolve = 0;\n    } else {\n      this.invMassSolve = this.invMass;\n      this.invInertiaSolve = this.invInertia;\n    }\n  }\n\n  /**\n   * Set the total density of the body\n   * @param density\n   */\n  setDensity(density) {\n    const totalArea = this.getArea();\n    this.mass = totalArea * density;\n    this.updateMassProperties();\n  }\n\n  /**\n   * Get the total area of all shapes in the body\n   * @returns total area of all shapes in the body\n   */\n  getArea() {\n    let totalArea = 0;\n    for (let i = 0; i < this.shapes.length; i++) {\n      totalArea += this.shapes[i].area;\n    }\n    return totalArea;\n  }\n\n  /**\n   * Get the AABB from the body. The AABB is updated if necessary.\n   * @return The AABB instance from the body.\n   */\n  getAABB() {\n    if (this.aabbNeedsUpdate) {\n      this.updateAABB();\n    }\n    return this.aabb;\n  }\n\n  /**\n   * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.\n   */\n  updateAABB() {\n    const shapes = this.shapes,\n      N = shapes.length,\n      offset = updateAABB_tmp,\n      bodyAngle = this.angle;\n    for (let i = 0; i !== N; i++) {\n      const shape = shapes[i],\n        angle = shape.angle + bodyAngle;\n\n      // Get shape world offset\n      toGlobalFrame(offset, shape.position, this.position, bodyAngle);\n\n      // Get shape AABB\n      shape.computeAABB(updateAABB_shapeAABB, offset, angle);\n      if (i === 0) {\n        this.aabb.copy(updateAABB_shapeAABB);\n      } else {\n        this.aabb.extend(updateAABB_shapeAABB);\n      }\n    }\n    this.aabbNeedsUpdate = false;\n  }\n\n  /**\n   * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.\n   */\n  updateBoundingRadius() {\n    const shapes = this.shapes;\n    const N = shapes.length;\n    let radius = 0;\n    for (let i = 0; i !== N; i++) {\n      const shape = shapes[i],\n        offset = length(shape.position),\n        r = shape.boundingRadius;\n      if (offset + r > radius) {\n        radius = offset + r;\n      }\n    }\n    this.boundingRadius = radius;\n  }\n\n  /**\n   * Add a shape to the body. You can pass a local transform when adding a shape,\n   * so that the shape gets an offset and angle relative to the body center of mass.\n   * Will automatically update the mass properties and bounding radius.\n   *\n   * @param shape\n   * @param offset Local body offset of the shape.\n   * @param angle Local body angle.\n   *\n   * @example\n   *     var body = new Body(),\n   *         shape = new Circle({ radius: 1 });\n   *\n   *     // Add the shape to the body, positioned in the center\n   *     body.addShape(shape);\n   *\n   *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.\n   *     body.addShape(shape,[1,0]);\n   *\n   *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.\n   *     body.addShape(shape,[0,1],Math.PI/2);\n   */\n  addShape(shape, offset, angle) {\n    if (shape.body) {\n      throw new Error('A shape can only be added to one body.');\n    }\n    const world = this.world;\n    if (world && world.stepping) {\n      throw new Error('A shape cannot be added during step.');\n    }\n    shape.body = this;\n\n    // Copy the offset vector\n    if (offset) {\n      copy(shape.position, offset);\n    } else {\n      set(shape.position, 0, 0);\n    }\n    shape.angle = angle || 0;\n    this.shapes.push(shape);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n    this.aabbNeedsUpdate = true;\n  }\n\n  /**\n   * Remove a shape.\n   * @param shape\n   * @return True if the shape was found and removed, else false.\n   */\n  removeShape(shape) {\n    const world = this.world;\n    if (world && world.stepping) {\n      throw new Error('A shape cannot be removed during step.');\n    }\n    const idx = this.shapes.indexOf(shape);\n    if (idx !== -1) {\n      this.shapes.splice(idx, 1);\n      this.aabbNeedsUpdate = true;\n      shape.body = null;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Updates .inertia, .invMass, .invInertia for this Body. Should be called when changing the structure or mass of the Body.\n   *\n   * @example\n   *     body.mass += 1;\n   *     body.updateMassProperties();\n   */\n  updateMassProperties() {\n    if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {\n      this.mass = Number.MAX_VALUE;\n      this.invMass = 0;\n      this.inertia = Number.MAX_VALUE;\n      this.invInertia = 0;\n    } else {\n      const shapes = this.shapes;\n      const N = shapes.length;\n      let I = 0;\n      if (!this.fixedRotation) {\n        for (let i = 0; i < N; i++) {\n          const shape = shapes[i],\n            r2 = squaredLength(shape.position),\n            Icm = shape.computeMomentOfInertia();\n          I += Icm + r2;\n        }\n        this.inertia = this.mass * I;\n        this.invInertia = I > 0 ? 1 / I : 0;\n      } else {\n        this.inertia = Number.MAX_VALUE;\n        this.invInertia = 0;\n      }\n\n      // Inverse mass properties are easy\n      this.invMass = 1 / this.mass;\n      set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);\n    }\n  }\n\n  /**\n   * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.\n   * @param force The force vector to add, oriented in world space.\n   * @param relativePoint A point relative to the body in world space. If not given, it is set to zero and all of the force will be exerted on the center of mass.\n   * @example\n   *     var body = new Body({ mass: 1 });\n   *     var relativePoint = [1, 0]; // Will apply the force at [body.position[0] + 1, body.position[1]]\n   *     var force = [0, 1]; // up\n   *     body.applyForce(force, relativePoint);\n   *     console.log(body.force); // [0, 1]\n   *     console.log(body.angularForce); // 1\n   */\n  applyForce(force, relativePoint) {\n    // Add linear force\n    add(this.force, this.force, force);\n    if (relativePoint) {\n      // Compute produced rotational force\n      const rotForce = crossLength(relativePoint, force);\n\n      // Add rotational force\n      this.angularForce += rotForce;\n    }\n  }\n\n  /**\n   * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.\n   * @param localForce The force vector to add, oriented in local body space.\n   * @param localPoint A point relative to the body in local body space. If not given, it is set to zero and all of the force will be exerted on the center of mass.\n   * @example\n   *     var body = new Body({ mass: 1 });\n   *     var localPoint = [1, 0]; // x=1 locally in the body\n   *     var localForce = [0, 1]; // up, locally in the body\n   *     body.applyForceLocal(localForce, localPoint);\n   *     console.log(body.force); // [0, 1]\n   *     console.log(body.angularForce); // 1\n   */\n  applyForceLocal(localForce, localPoint) {\n    localPoint = localPoint || applyForce_pointLocal;\n    const worldForce = applyForce_forceWorld;\n    const worldPoint = applyForce_pointWorld;\n    this.vectorToWorldFrame(worldForce, localForce);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyForce(worldForce, worldPoint);\n  }\n\n  /**\n   * Apply impulse to a point relative to the body. This could for example be a point on the Body surface.\n   * An impulse is a force added to a body during a short period of time (impulse = force * time).\n   * Impulses will be added to Body.velocity and Body.angularVelocity.\n   * @param impulseVector The impulse vector to add, oriented in world space.\n   * @param relativePoint A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.\n   * @example\n   *     var body = new Body({ mass: 1 });\n   *     var relativePoint = [0, 0]; // center of the body\n   *     var impulseVector = [0, 1]; // world up\n   *     body.applyImpulse(impulseVector, relativePoint);\n   */\n  applyImpulse(impulseVector, relativePoint) {\n    if (this.type !== Body.DYNAMIC) {\n      return;\n    }\n\n    // Compute produced central impulse velocity\n    const velo = applyImpulse_velo;\n    scale(velo, impulseVector, this.invMass);\n    multiply(velo, this.massMultiplier, velo);\n\n    // Add linear impulse\n    add(this.velocity, velo, this.velocity);\n    if (relativePoint) {\n      // Compute produced rotational impulse velocity\n      let rotVelo = crossLength(relativePoint, impulseVector);\n      rotVelo *= this.invInertia;\n\n      // Add rotational Impulse\n      this.angularVelocity += rotVelo;\n    }\n  }\n\n  /**\n   * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n   * @param localImpulse The impulse vector to add, oriented in local body space.\n   * @param localPoint A point relative to the body in local body space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.\n   * @example\n   *     var body = new Body({ mass: 1 });\n   *     var localPoint = [1, 0]; // x=1, locally in the body\n   *     var localImpulse = [0, 1]; // up, locally in the body\n   *     body.applyImpulseLocal(localImpulse, localPoint);\n   *     console.log(body.velocity); // [1, 0]\n   *     console.log(body.angularVelocity); // 1\n   */\n  applyImpulseLocal(localImpulse, localPoint) {\n    localPoint = localPoint || applyImpulse_pointLocal;\n    const worldImpulse = applyImpulse_impulseWorld;\n    const worldPoint = applyImpulse_pointWorld;\n    this.vectorToWorldFrame(worldImpulse, localImpulse);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyImpulse(worldImpulse, worldPoint);\n  }\n\n  /**\n   * Transform a world point to local body frame.\n   * @param out The point to store the result in\n   * @param worldPoint The input world point\n   */\n  toLocalFrame(out, worldPoint) {\n    toLocalFrame(out, worldPoint, this.position, this.angle);\n  }\n\n  /**\n   * Transform a local point to world frame.\n   * @param out The point to store the result in\n   * @param localPoint The input local point\n   */\n  toWorldFrame(out, localPoint) {\n    toGlobalFrame(out, localPoint, this.position, this.angle);\n  }\n\n  /**\n   * Transform a world vector to local body frame.\n   * @param out The vector to store the result in\n   * @param worldVector The input world vector\n   */\n  vectorToLocalFrame(out, worldVector) {\n    vectorToLocalFrame(out, worldVector, this.angle);\n  }\n\n  /**\n   * Transform a local vector to world frame.\n   * @param out The vector to store the result in\n   * @param localVector The input local vector\n   */\n  vectorToWorldFrame(out, localVector) {\n    vectorToGlobalFrame(out, localVector, this.angle);\n  }\n\n  /**\n   * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.\n   * @param path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.\n   * @param options\n   * @param options.optimalDecomp=false   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n   * @param options.skipSimpleCheck=false Set to true if you already know that the path is not intersecting itself.\n   * @param options.removeCollinearPoints=false Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n   * @return True on success, else false.\n   * @example\n   *     var body = new Body();\n   *     var path = [\n   *         [-1, 1],\n   *         [-1, 0],\n   *         [1, 0],\n   *         [1, 1],\n   *         [0.5, 0.5]\n   *     ];\n   *     body.fromPolygon(path);\n   *     console.log(body.shapes); // [Convex, Convex, ...]\n   */\n  fromPolygon(path, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    // Remove all shapes\n    for (let i = this.shapes.length; i >= 0; --i) {\n      this.removeShape(this.shapes[i]);\n    }\n\n    // Copy the path\n    const p = [];\n    for (let i = 0; i < path.length; i++) {\n      p[i] = clone(path[i]);\n    }\n\n    // Make it counter-clockwise\n    makeCCW(p);\n\n    // Remove collinear points\n    if (options.removeCollinearPoints !== undefined) {\n      if (typeof options.removeCollinearPoints === 'boolean') {\n        if (options.removeCollinearPoints === true) {\n          removeCollinearPoints(p);\n        }\n      } else {\n        removeCollinearPoints(p, options.removeCollinearPoints);\n      }\n    }\n\n    // Check if any line segment intersects the path itself\n    if (!options.skipSimpleCheck) {\n      if (!isSimple(p)) {\n        return false;\n      }\n    }\n\n    // Save this path for later\n    const concavePath = this.concavePath = [];\n    for (let i = 0; i < p.length; i++) {\n      concavePath[i] = clone(p[i]);\n    }\n\n    // Slow or fast decomp?\n    let convexes;\n    if (options.optimalDecomp) {\n      convexes = decomp(p);\n      if (convexes === false) {\n        throw new Error('Convex decomposition failed!');\n      }\n    } else {\n      convexes = quickDecomp(p);\n    }\n    const cm = create();\n\n    // Add convexes\n    for (let i = 0; i !== convexes.length; i++) {\n      // Create convex\n      let c = new Convex({\n        vertices: convexes[i]\n      });\n\n      // Move all vertices so its center of mass is in the local center of the convex\n      for (let j = 0; j !== c.vertices.length; j++) {\n        const v = c.vertices[j];\n        subtract(v, v, c.centerOfMass);\n      }\n      copy(cm, c.centerOfMass);\n      c = new Convex({\n        vertices: c.vertices\n      });\n\n      // Add the shape\n      this.addShape(c, cm);\n    }\n    this.adjustCenterOfMass();\n    this.aabbNeedsUpdate = true;\n    return true;\n  }\n\n  /**\n   * Moves the shape offsets so their center of mass becomes the body center of mass.\n   *\n   * @example\n   *     var body = new Body({ position: [0, 0] });\n   *     var shape = new Circle({ radius: 1 });\n   *     body.addShape(shape, [1, 0], 0);\n   *     body.adjustCenterOfMass();\n   *     console.log(body.position); // [1, 0]\n   *     console.log(shape.position); // [0, 0]\n   */\n  adjustCenterOfMass() {\n    const offset_times_area = adjustCenterOfMass_tmp2;\n    const sum = adjustCenterOfMass_tmp3;\n    const cm = adjustCenterOfMass_tmp4;\n    let totalArea = 0;\n    set(sum, 0, 0);\n    for (let i = 0; i !== this.shapes.length; i++) {\n      const s = this.shapes[i];\n      scale(offset_times_area, s.position, s.area);\n      add(sum, sum, offset_times_area);\n      totalArea += s.area;\n    }\n    scale(cm, sum, 1 / totalArea);\n\n    // Now move all shapes\n    for (let i = 0; i !== this.shapes.length; i++) {\n      const s = this.shapes[i];\n      subtract(s.position, s.position, cm);\n    }\n\n    // Move the body position too\n    add(this.position, this.position, cm);\n\n    // And concave path\n    for (let i = 0; this.concavePath && i < this.concavePath.length; i++) {\n      subtract(this.concavePath[i], this.concavePath[i], cm);\n    }\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n  }\n\n  /**\n   * Sets the force on the body to zero.\n   */\n  setZeroForce() {\n    const f = this.force;\n    f[0] = f[1] = this.angularForce = 0;\n  }\n\n  /**\n   * Apply damping, see <a href=\"http://code.google.com/p/bullet/issues/detail?id=74\">this</a> for details.\n   * @param dt Current time step\n   */\n  applyDamping(dt) {\n    if (this.type === Body.DYNAMIC) {\n      // Only for dynamic bodies\n      const v = this.velocity;\n      scale(v, v, Math.pow(1 - this.damping, dt));\n      this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);\n    }\n  }\n\n  /**\n   * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.\n   * Sets the sleepState to {@link Body.AWAKE} and emits the wakeUp event if the body wasn't awake before.\n   */\n  wakeUp() {\n    const s = this.sleepState;\n    this.sleepState = Body.AWAKE;\n    this.idleTime = 0;\n    if (s !== Body.AWAKE) {\n      this.emit({\n        type: 'wakeup'\n      });\n    }\n  }\n\n  /**\n   * Force body sleep\n   */\n  sleep() {\n    this.sleepState = Body.SLEEPING;\n    this.angularVelocity = this.angularForce = 0;\n    set(this.velocity, 0, 0);\n    set(this.force, 0, 0);\n    this.emit({\n      type: 'sleep'\n    });\n  }\n\n  /**\n   * Called every timestep to update internal sleep timer and change sleep state if needed.\n   * @param time The world time in seconds\n   * @param dontSleep\n   * @param dt\n   */\n  sleepTick(time, dontSleep, dt) {\n    if (!this.allowSleep || this.type === Body.SLEEPING) {\n      return;\n    }\n    this.wantsToSleep = false;\n    const speedSquared = squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2),\n      speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);\n\n    // Add to idle time\n    if (speedSquared >= speedLimitSquared) {\n      this.idleTime = 0;\n      this.sleepState = Body.AWAKE;\n    } else {\n      this.idleTime += dt;\n      if (this.sleepState !== Body.SLEEPY) {\n        this.sleepState = Body.SLEEPY;\n        this.emit({\n          type: 'sleepy'\n        });\n      }\n    }\n    if (this.idleTime > this.sleepTimeLimit) {\n      if (!dontSleep) {\n        this.sleep();\n      } else {\n        this.wantsToSleep = true;\n      }\n    }\n  }\n\n  /**\n   * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.\n   * @param body\n   * @return if the body overlaps the given body\n   */\n  overlaps(body) {\n    if (this.world === null) {\n      return false;\n    }\n    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);\n  }\n\n  /**\n   * Move the body forward in time given its current velocity.\n   * @param dt\n   */\n  integrate(dt) {\n    const minv = this.invMass,\n      f = this.force,\n      pos = this.position,\n      velo = this.velocity;\n\n    // Save old position\n    copy(this.previousPosition, this.position);\n    this.previousAngle = this.angle;\n\n    // Velocity update\n    if (!this.fixedRotation) {\n      this.angularVelocity += this.angularForce * this.invInertia * dt;\n    }\n    scale(integrate_fhMinv, f, dt * minv);\n    multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);\n    add(velo, integrate_fhMinv, velo);\n\n    // CCD\n    if (!this.integrateToTimeOfImpact(dt)) {\n      // Regular position update\n      scale(integrate_velodt, velo, dt);\n      add(pos, pos, integrate_velodt);\n      if (!this.fixedRotation) {\n        this.angle += this.angularVelocity * dt;\n      }\n    }\n    this.aabbNeedsUpdate = true;\n  }\n\n  /**\n   * Get velocity of a point in the body.\n   * @param result A vector to store the result in\n   * @param relativePoint A world oriented vector, indicating the position of the point to get the velocity from\n   * @return The result vector\n   *\n   * @example\n   *     var body = new Body({\n   *         mass: 1,\n   *         velocity: [1, 0],\n   *         angularVelocity: 1\n   *     });\n   *     var result = [];\n   *     var point = [1, 0];\n   *     body.getVelocityAtPoint(result, point);\n   *     console.log(result); // [1, 1]\n   */\n  getVelocityAtPoint(result, relativePoint) {\n    crossVZ(result, relativePoint, this.angularVelocity);\n    subtract(result, this.velocity, result);\n    return result;\n  }\n  integrateToTimeOfImpact(dt) {\n    if (this.world === null) {\n      throw new Error('world is not set for body');\n    }\n    if (this.ccdSpeedThreshold < 0 || squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {\n      return false;\n    }\n\n    // Ignore all the ignored body pairs\n    // This should probably be done somewhere else for optimization\n    const ignoreBodies = [];\n    const disabledPairs = this.world.disabledBodyCollisionPairs;\n    for (let i = 0; i < disabledPairs.length; i += 2) {\n      const bodyA = disabledPairs[i];\n      const bodyB = disabledPairs[i + 1];\n      if (bodyA === this) {\n        ignoreBodies.push(bodyB);\n      } else if (bodyB === this) {\n        ignoreBodies.push(bodyA);\n      }\n    }\n    normalize(integrateToTimeOfImpact_direction, this.velocity);\n    scale(integrateToTimeOfImpact_end, this.velocity, dt);\n    add(integrateToTimeOfImpact_end, integrateToTimeOfImpact_end, this.position);\n    subtract(integrateToTimeOfImpact_startToEnd, integrateToTimeOfImpact_end, this.position);\n    const startToEndAngle = this.angularVelocity * dt;\n    const len = length(integrateToTimeOfImpact_startToEnd);\n    let timeOfImpact = 1;\n    let hitBody = null;\n    copy(integrateToTimeOfImpact_ray.from, this.position);\n    copy(integrateToTimeOfImpact_ray.to, integrateToTimeOfImpact_end);\n    integrateToTimeOfImpact_ray.update();\n    for (let i = 0; i < this.shapes.length; i++) {\n      const shape = this.shapes[i];\n      integrateToTimeOfImpact_result.reset();\n      integrateToTimeOfImpact_ray.collisionGroup = shape.collisionGroup;\n      integrateToTimeOfImpact_ray.collisionMask = shape.collisionMask;\n      this.world.raycast(integrateToTimeOfImpact_result, integrateToTimeOfImpact_ray);\n      hitBody = integrateToTimeOfImpact_result.body;\n      if (hitBody !== null && (hitBody === this || ignoreBodies.indexOf(hitBody) !== -1)) {\n        hitBody = null;\n      }\n      if (hitBody) {\n        break;\n      }\n    }\n    if (!hitBody || !timeOfImpact) {\n      return false;\n    }\n    integrateToTimeOfImpact_result.getHitPoint(integrateToTimeOfImpact_end, integrateToTimeOfImpact_ray);\n    subtract(integrateToTimeOfImpact_startToEnd, integrateToTimeOfImpact_end, this.position);\n    timeOfImpact = distance(integrateToTimeOfImpact_end, this.position) / len; // guess\n\n    const rememberAngle = this.angle;\n    copy(integrateToTimeOfImpact_rememberPosition, this.position);\n\n    // Got a start and end point. Approximate time of impact using binary search\n    let iter = 0;\n    let tmin = 0;\n    let tmid = timeOfImpact;\n    let tmax = 1;\n    while (tmax >= tmin && iter < this.ccdIterations) {\n      iter++;\n\n      // calculate the midpoint\n      tmid = (tmax + tmin) / 2;\n\n      // Move the body to that point\n      scale(integrate_velodt, integrateToTimeOfImpact_startToEnd, tmid);\n      add(this.position, integrateToTimeOfImpact_rememberPosition, integrate_velodt);\n      this.angle = rememberAngle + startToEndAngle * tmid;\n      this.updateAABB();\n\n      // check overlap\n      const overlaps = this.aabb.overlaps(hitBody.aabb) && this.world.narrowphase.bodiesOverlap(this, hitBody, true);\n      if (overlaps) {\n        // change max to search lower interval\n        tmax = tmid;\n      } else {\n        // change min to search upper interval\n        tmin = tmid;\n      }\n    }\n    timeOfImpact = tmax; // Need to guarantee overlap to resolve collisions\n\n    copy(this.position, integrateToTimeOfImpact_rememberPosition);\n    this.angle = rememberAngle;\n\n    // move to TOI\n    scale(integrate_velodt, integrateToTimeOfImpact_startToEnd, timeOfImpact);\n    add(this.position, this.position, integrate_velodt);\n    if (!this.fixedRotation) {\n      this.angle += startToEndAngle * timeOfImpact;\n    }\n    return true;\n  }\n  resetConstraintVelocity() {\n    const vlambda = this.vlambda;\n    set(vlambda, 0, 0);\n    this.wlambda = 0;\n  }\n  addConstraintVelocity() {\n    const v = this.velocity;\n    add(v, v, this.vlambda);\n    this.angularVelocity += this.wlambda;\n  }\n}\nconst updateAABB_shapeAABB = new AABB();\nconst updateAABB_tmp = create();\nconst applyForce_forceWorld = create();\nconst applyForce_pointWorld = create();\nconst applyForce_pointLocal = create();\nconst applyImpulse_velo = create();\nconst applyImpulse_impulseWorld = create();\nconst applyImpulse_pointWorld = create();\nconst applyImpulse_pointLocal = create();\nconst adjustCenterOfMass_tmp2 = create();\nconst adjustCenterOfMass_tmp3 = create();\nconst adjustCenterOfMass_tmp4 = create();\nconst integrate_fhMinv = create();\nconst integrate_velodt = create();\nconst integrateToTimeOfImpact_result = new RaycastResult();\nconst integrateToTimeOfImpact_ray = new Ray({\n  mode: Ray.CLOSEST,\n  skipBackfaces: true\n});\nconst integrateToTimeOfImpact_direction = create();\nconst integrateToTimeOfImpact_end = create();\nconst integrateToTimeOfImpact_startToEnd = create();\nconst integrateToTimeOfImpact_rememberPosition = create();\n\n/**\n * Base class for broadphase implementations. Don't use this class directly.\n */\nclass Broadphase {\n  /**\n   * Axis aligned bounding box type.\n   */\n  static AABB = 1;\n\n  /**\n   * Bounding circle type.\n   */\n  static BOUNDING_CIRCLE = 2;\n\n  /**\n   * Naive Broadphase\n   */\n  static NAIVE = 1;\n\n  /**\n   * SAP Broadphase\n   */\n  static SAP = 2;\n\n  /**\n   * Check whether the bounding radius of two bodies overlap.\n   * @param bodyA\n   * @param bodyB\n   * @returns\n   */\n  static boundingRadiusCheck(bodyA, bodyB) {\n    const d2 = squaredDistance(bodyA.position, bodyB.position),\n      r = bodyA.boundingRadius + bodyB.boundingRadius;\n    return d2 <= r * r;\n  }\n\n  /**\n   * Check whether the AABB of two bodies overlap.\n   * @param bodyA\n   * @param bodyB\n   * @returns\n   */\n  static aabbCheck(bodyA, bodyB) {\n    return bodyA.getAABB().overlaps(bodyB.getAABB());\n  }\n\n  /**\n   * Check whether two bodies are allowed to collide at all.\n   * @param bodyA\n   * @param bodyB\n   */\n  static canCollide(bodyA, bodyB) {\n    const KINEMATIC = Body.KINEMATIC;\n    const STATIC = Body.STATIC;\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Cannot collide static bodies\n    if (typeA === STATIC && typeB === STATIC) {\n      return false;\n    }\n\n    // Cannot collide static vs kinematic bodies\n    if (typeA === KINEMATIC && typeB === STATIC || typeA === STATIC && typeB === KINEMATIC) {\n      return false;\n    }\n\n    // Cannot collide kinematic vs kinematic\n    if (typeA === KINEMATIC && typeB === KINEMATIC) {\n      return false;\n    }\n\n    // Cannot collide both sleeping bodies\n    if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {\n      return false;\n    }\n\n    // Cannot collide if one is static and the other is sleeping\n    if (bodyA.sleepState === Body.SLEEPING && typeB === STATIC || bodyB.sleepState === Body.SLEEPING && typeA === STATIC) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().\n   */\n\n  /**\n   * The world to search for collision pairs in. To change it, use .setWorld()\n   */\n\n  /**\n   * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.\n   */\n\n  constructor(type) {\n    this.type = type;\n    this.result = [];\n    this.world = undefined;\n    this.boundingVolumeType = Broadphase.AABB;\n  }\n\n  /**\n   * Get all potential intersecting body pairs.\n   * @param world The world to search in.\n   * @return An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).\n   */\n\n  /**\n   * Returns all the bodies within an AABB.\n   * @param world\n   * @param aabb\n   * @param result\n   */\n\n  /**\n   * Set the world that we are searching for collision pairs in.\n   * @param world\n   */\n  setWorld(world) {\n    this.world = world;\n  }\n\n  /**\n   * Check whether the bounding volumes of two bodies overlap.\n   * @param bodyA\n   * @param bodyB\n   */\n  boundingVolumeCheck(bodyA, bodyB) {\n    switch (this.boundingVolumeType) {\n      case Broadphase.BOUNDING_CIRCLE:\n        return Broadphase.boundingRadiusCheck(bodyA, bodyB);\n      case Broadphase.AABB:\n        return Broadphase.aabbCheck(bodyA, bodyB);\n      default:\n        throw new Error('Bounding volume type not recognized: ' + this.boundingVolumeType);\n    }\n  }\n}\n\n/**\n * Naive broadphase implementation. Does N^2 tests.\n */\nclass NaiveBroadphase extends Broadphase {\n  constructor() {\n    super(Broadphase.NAIVE);\n  }\n\n  /**\n   * Get the colliding pairs\n   * @param world\n   * @return\n   */\n  getCollisionPairs(world) {\n    const bodies = world.bodies;\n    const result = this.result;\n    result.length = 0;\n    for (let i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {\n      const bi = bodies[i];\n      for (let j = 0; j < i; j++) {\n        const bj = bodies[j];\n        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {\n          result.push(bi, bj);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns all the bodies within an AABB.\n   * @param world\n   * @param aabb\n   * @param result An array to store resulting bodies in.\n   */\n  aabbQuery(world, aabb, result) {\n    if (result === void 0) {\n      result = [];\n    }\n    const bodies = world.bodies;\n    for (let i = 0; i < bodies.length; i++) {\n      const b = bodies[i];\n      if (b.aabbNeedsUpdate) {\n        b.updateAABB();\n      }\n      if (b.aabb.overlaps(aabb)) {\n        result.push(b);\n      }\n    }\n    return result;\n  }\n}\n\n/**\n * (Note that this options object will be passed on to the {@link Shape} constructor.)\n */\n\n/**\n * Box shape class.\n *\n * @example\n *     var body = new Body({ mass: 1 });\n *     var boxShape = new Box({\n *         width: 2,\n *         height: 1\n *     });\n *     body.addShape(boxShape);\n */\nclass Box extends Convex {\n  /**\n   * Total width of the box\n   */\n\n  /**\n   * Total height of the box\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const width = options.width ?? 1;\n    const height = options.height ?? 1;\n    const verts = [fromValues(-width / 2, -height / 2), fromValues(width / 2, -height / 2), fromValues(width / 2, height / 2), fromValues(-width / 2, height / 2)];\n    const convexOptions = {\n      ...options,\n      type: Shape.BOX,\n      vertices: verts\n    };\n    super(convexOptions);\n    this.width = width;\n    this.height = height;\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n\n  /**\n   * Compute moment of inertia\n   */\n  computeMomentOfInertia() {\n    const w = this.width;\n    const h = this.height;\n    return (h * h + w * w) / 12;\n  }\n\n  /**\n   * Update the bounding radius\n   */\n  updateBoundingRadius() {\n    const w = this.width,\n      h = this.height;\n    this.boundingRadius = Math.sqrt(w * w + h * h) / 2;\n  }\n\n  /**\n   * @param out The resulting AABB.\n   * @param position\n   * @param angle\n   */\n  computeAABB(out, position, angle) {\n    const c = Math.abs(Math.cos(angle));\n    const s = Math.abs(Math.sin(angle));\n    const w = this.width;\n    const h = this.height;\n    const height = (w * s + h * c) * 0.5;\n    const width = (h * s + w * c) * 0.5;\n    const l = out.lowerBound;\n    const u = out.upperBound;\n    const px = position[0];\n    const py = position[1];\n    l[0] = px - width;\n    l[1] = py - height;\n    u[0] = px + width;\n    u[1] = py + height;\n  }\n  updateArea() {\n    this.area = this.width * this.height;\n  }\n  pointTest(localPoint) {\n    return Math.abs(localPoint[0]) <= this.width * 0.5 && Math.abs(localPoint[1]) <= this.height * 0.5;\n  }\n}\n\n/**\n * (Note that this options object will be passed on to the {@link Shape} constructor.)\n */\n\n/**\n * Circle shape class.\n *\n * @example\n *     var body = new Body({ mass: 1 });\n *     var circleShape = new Circle({\n *         radius: 1\n *     });\n *     body.addShape(circleShape);\n */\nclass Circle extends Shape {\n  /**\n   * The radius of the circle.\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const params = {\n      radius: 1,\n      ...options,\n      type: Shape.CIRCLE\n    };\n    super(params);\n    this.radius = params.radius;\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n  updateBoundingRadius() {\n    this.boundingRadius = this.radius;\n  }\n  computeMomentOfInertia() {\n    const r = this.radius;\n    return r * r / 2;\n  }\n  updateArea() {\n    this.area = Math.PI * this.radius * this.radius;\n  }\n  computeAABB(out, position) {\n    const r = this.radius;\n    set(out.upperBound, r, r);\n    set(out.lowerBound, -r, -r);\n    if (position) {\n      add(out.lowerBound, out.lowerBound, position);\n      add(out.upperBound, out.upperBound, position);\n    }\n  }\n  raycast(result, ray, position) {\n    const from = ray.from;\n    const to = ray.to;\n    const r = this.radius;\n    const a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n    const b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));\n    const c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);\n    const delta = Math.pow(b, 2) - 4 * a * c;\n    const intersectionPoint = Ray_intersectSphere_intersectionPoint;\n    const normal = Ray_intersectSphere_normal;\n    if (delta < 0) {\n      // No intersection\n      return;\n    } else if (delta === 0) {\n      // single intersection point\n      lerp(intersectionPoint, from, to, delta);\n      subtract(normal, intersectionPoint, position);\n      normalize(normal, normal);\n      ray.reportIntersection(result, delta, normal, -1);\n    } else {\n      const sqrtDelta = Math.sqrt(delta);\n      const inv2a = 1 / (2 * a);\n      const d1 = (-b - sqrtDelta) * inv2a;\n      const d2 = (-b + sqrtDelta) * inv2a;\n      if (d1 >= 0 && d1 <= 1) {\n        lerp(intersectionPoint, from, to, d1);\n        subtract(normal, intersectionPoint, position);\n        normalize(normal, normal);\n        ray.reportIntersection(result, d1, normal, -1);\n        if (result.shouldStop(ray)) {\n          return;\n        }\n      }\n      if (d2 >= 0 && d2 <= 1) {\n        lerp(intersectionPoint, from, to, d2);\n        subtract(normal, intersectionPoint, position);\n        normalize(normal, normal);\n        ray.reportIntersection(result, d2, normal, -1);\n      }\n    }\n  }\n  pointTest(localPoint) {\n    const radius = this.radius;\n    return squaredLength(localPoint) <= radius * radius;\n  }\n}\nconst Ray_intersectSphere_intersectionPoint = create();\nconst Ray_intersectSphere_normal = create();\n\n/**\n * Base class for constraint equations.\n */\nclass Equation {\n  /**\n   * The default stiffness when creating a new Equation.\n   */\n  static DEFAULT_STIFFNESS = 1e6;\n\n  /**\n   * The default relaxation when creating a new Equation.\n   */\n  static DEFAULT_RELAXATION = 4;\n\n  /**\n   * Whether this equation is enabled or not. If true, it will be added to the solver.\n   */\n\n  /**\n   * Minimum force to apply when solving.\n   */\n\n  /**\n   * Max force to apply when solving.\n   */\n\n  /**\n   * Cap the constraint violation (G*q) to this value.\n   */\n\n  /**\n   * First body participating in the constraint\n   */\n\n  /**\n   * Second body participating in the constraint\n   */\n\n  /**\n   * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n   */\n\n  /**\n   * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n   */\n\n  /**\n   * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n   */\n\n  /**\n   * Indicates if stiffness or relaxation was changed.\n   */\n\n  /**\n   * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n   */\n\n  /**\n   * Relative velocity.\n   */\n\n  /**\n   * Constructor for an Equation\n   * @param bodyA First body participating in the equation\n   * @param bodyB Second body participating in the equation\n   * @param minForce Minimum force to apply. Default: -Number.MAX_VALUE\n   * @param maxForce Maximum force to apply. Default: Number.MAX_VALUE\n   * @param bodyB\n   * @param minForce\n   * @param maxForce\n   */\n  constructor(bodyA, bodyB, minForce, maxForce) {\n    this.bodyA = bodyA;\n    this.bodyB = bodyB;\n    this.minForce = minForce ?? -Number.MAX_VALUE;\n    this.maxForce = maxForce ?? Number.MAX_VALUE;\n    this.maxBias = Number.MAX_VALUE;\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n    this.G = new ARRAY_TYPE(6);\n    for (let i = 0; i < 6; i++) {\n      this.G[i] = 0;\n    }\n    this.offset = 0;\n    this.a = 0;\n    this.b = 0;\n    this.epsilon = 0;\n    this.timeStep = 1 / 60;\n    this.needsUpdate = true;\n    this.multiplier = 0;\n    this.relativeVelocity = 0;\n    this.enabled = true;\n\n    // Temp stuff\n    this.lambda = this.B = this.invC = this.minForceDt = this.maxForceDt = 0;\n    this.index = -1;\n  }\n  update() {\n    const k = this.stiffness,\n      d = this.relaxation,\n      h = this.timeStep;\n    this.a = 4 / (h * (1 + 4 * d));\n    this.b = 4 * d / (1 + 4 * d);\n    this.epsilon = 4 / (h * h * k * (1 + 4 * d));\n    this.needsUpdate = false;\n  }\n\n  /**\n   * Multiply a jacobian entry with corresponding positions or velocities\n   */\n  gmult(G, vi, wi, vj, wj) {\n    return G[0] * vi[0] + G[1] * vi[1] + G[2] * wi + G[3] * vj[0] + G[4] * vj[1] + G[5] * wj;\n  }\n\n  /**\n   * Computes the RHS of the SPOOK equation\n   */\n  computeB(a, b, h) {\n    const GW = this.computeGW();\n    let Gq = this.computeGq();\n    const maxBias = this.maxBias;\n    if (Math.abs(Gq) > maxBias) {\n      Gq = Gq > 0 ? maxBias : -maxBias;\n    }\n    const GiMf = this.computeGiMf();\n    const B = -Gq * a - GW * b - GiMf * h;\n    return B;\n  }\n\n  /**\n   * Computes G\\*q, where q are the generalized body coordinates\n   */\n  computeGq() {\n    const G = this.G,\n      bi = this.bodyA,\n      bj = this.bodyB,\n      ai = bi.angle,\n      aj = bj.angle;\n    return this.gmult(G, qi, ai, qj, aj) + this.offset;\n  }\n\n  /**\n   * Computes G\\*W, where W are the body velocities\n   */\n  computeGW() {\n    const G = this.G,\n      bi = this.bodyA,\n      bj = this.bodyB,\n      vi = bi.velocity,\n      vj = bj.velocity,\n      wi = bi.angularVelocity,\n      wj = bj.angularVelocity;\n    return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;\n  }\n\n  /**\n   * Computes G\\*Wlambda, where W are the body velocities\n   */\n  computeGWlambda() {\n    const G = this.G,\n      bi = this.bodyA,\n      bj = this.bodyB,\n      vi = bi.vlambda,\n      vj = bj.vlambda,\n      wi = bi.wlambda,\n      wj = bj.wlambda;\n    return this.gmult(G, vi, wi, vj, wj);\n  }\n\n  /**\n   * Computes G\\*inv(M)\\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n   */\n  computeGiMf() {\n    const bi = this.bodyA,\n      bj = this.bodyB,\n      fi = bi.force,\n      ti = bi.angularForce,\n      fj = bj.force,\n      tj = bj.angularForce,\n      invMassi = bi.invMassSolve,\n      invMassj = bj.invMassSolve,\n      invIi = bi.invInertiaSolve,\n      invIj = bj.invInertiaSolve,\n      G = this.G;\n    scale(iMfi, fi, invMassi);\n    multiply(iMfi, bi.massMultiplier, iMfi);\n    scale(iMfj, fj, invMassj);\n    multiply(iMfj, bj.massMultiplier, iMfj);\n    return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);\n  }\n\n  /**\n   * Computes G\\*inv(M)\\*G'\n   */\n  computeGiMGt() {\n    const bi = this.bodyA,\n      bj = this.bodyB,\n      invMassi = bi.invMassSolve,\n      invMassj = bj.invMassSolve,\n      invIi = bi.invInertiaSolve,\n      invIj = bj.invInertiaSolve,\n      G = this.G;\n    return G[0] * G[0] * invMassi * bi.massMultiplier[0] + G[1] * G[1] * invMassi * bi.massMultiplier[1] + G[2] * G[2] * invIi + G[3] * G[3] * invMassj * bj.massMultiplier[0] + G[4] * G[4] * invMassj * bj.massMultiplier[1] + G[5] * G[5] * invIj;\n  }\n\n  /**\n   * Add constraint velocity to the bodies.\n   * @param deltalambda\n   */\n  addToWlambda(deltalambda) {\n    const bi = this.bodyA,\n      bj = this.bodyB,\n      invMassi = bi.invMassSolve,\n      invMassj = bj.invMassSolve,\n      invIi = bi.invInertiaSolve,\n      invIj = bj.invInertiaSolve,\n      G = this.G;\n    addToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);\n    bi.wlambda += invIi * G[2] * deltalambda;\n    addToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);\n    bj.wlambda += invIj * G[5] * deltalambda;\n  }\n\n  /**\n   * Compute the denominator part of the SPOOK equation: C = G\\*inv(M)\\*G' + eps\n   * @param eps\n   */\n  computeInvC(eps) {\n    const invC = 1 / (this.computeGiMGt() + eps);\n    return invC;\n  }\n}\nconst qi = create();\nconst qj = create();\nconst iMfi = create();\nconst iMfj = create();\nfunction addToVLambda(vlambda, Gx, Gy, invMass, deltalambda, massMultiplier) {\n  vlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];\n  vlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];\n}\n\nfunction addSubSub(out, a, b, c, d) {\n  out[0] = a[0] + b[0] - c[0] - d[0];\n  out[1] = a[1] + b[1] - c[1] - d[1];\n}\nconst vi = create();\nconst vj = create();\nconst relVel = create();\nconst tmpShape$1 = new Circle({\n  radius: 1\n});\n\n/**\n * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.\n */\nclass ContactEquation extends Equation {\n  /**\n   * Vector from body i center of mass to the contact point.\n   */\n\n  /**\n   * World-oriented vector from body A center of mass to the contact point.\n   */\n\n  /**\n   * The normal vector, pointing out of body i\n   */\n\n  /**\n   * The restitution to use (0=no bounciness, 1=max bounciness).\n   */\n\n  /**\n   * This property is set to true if this is the first impact between the bodies (not persistant contact).\n   */\n\n  /**\n   * The shape in body i that triggered this contact.\n   */\n\n  constructor(bodyA, bodyB) {\n    super(bodyA, bodyB, 0, Number.MAX_VALUE);\n    this.contactPointA = create();\n    this.penetrationVec = create();\n    this.contactPointB = create();\n    this.normalA = create();\n    this.restitution = 0;\n    this.firstImpact = false;\n    this.shapeA = tmpShape$1;\n    this.shapeB = tmpShape$1;\n  }\n  computeB(a, b, h) {\n    const bi = this.bodyA,\n      bj = this.bodyB,\n      ri = this.contactPointA,\n      rj = this.contactPointB,\n      xi = bi.position,\n      xj = bj.position;\n    const n = this.normalA;\n    const G = this.G;\n\n    // Caluclate cross products\n    const rixn = crossLength(ri, n);\n    const rjxn = crossLength(rj, n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n\n    // Compute iteration\n    let GW, Gq;\n    if (this.firstImpact && this.restitution !== 0) {\n      Gq = 0;\n      GW = 1 / b * (1 + this.restitution) * this.computeGW();\n    } else {\n      // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector\n      const penetrationVec = this.penetrationVec;\n      addSubSub(penetrationVec, xj, rj, xi, ri);\n      Gq = dot(n, penetrationVec) + this.offset;\n      GW = this.computeGW();\n    }\n    const GiMf = this.computeGiMf();\n    const B = -Gq * a - GW * b - h * GiMf;\n    return B;\n  }\n\n  /**\n   * Get the relative velocity along the normal vector.\n   */\n  getVelocityAlongNormal() {\n    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);\n    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);\n    subtract(relVel, vi, vj);\n    return dot(this.normalA, relVel);\n  }\n}\n\n/**\n * Object pooling utility.\n */\nclass Pool {\n  objects = [];\n  constructor(options) {\n    if (options?.size !== undefined) {\n      this.resize(options.size);\n    }\n  }\n\n  /**\n   * Creates a new object in the pool\n   */\n\n  /**\n   * Destroys an object\n   * @param object the object to destroy\n   */\n\n  /**\n   * Resizes the pool\n   * @param size\n   * @return Self, for chaining\n   */\n  resize(size) {\n    const objects = this.objects;\n    while (objects.length > size) {\n      objects.pop();\n    }\n    while (objects.length < size) {\n      objects.push(this.create());\n    }\n    return this;\n  }\n\n  /**\n   * Get an object from the pool or create a new instance.\n   * @return an object from the pool\n   */\n  get() {\n    const objects = this.objects;\n    return objects.length ? objects.pop() : this.create();\n  }\n\n  /**\n   * Release an object back to the pool.\n   * @param object\n   * @return Self for chaining\n   */\n  release(object) {\n    this.destroy(object);\n    this.objects.push(object);\n    return this;\n  }\n}\n\nclass ContactEquationPool extends Pool {\n  create() {\n    return new ContactEquation(tmpBody$2, tmpBody$2);\n  }\n  destroy(equation) {\n    equation.bodyA = equation.bodyB = tmpBody$2;\n    return this;\n  }\n}\nconst tmpBody$2 = new Body();\n\n/**\n * Constrains the slipping in a contact along a tangent\n */\nclass FrictionEquation extends Equation {\n  /**\n   * Relative vector from center of body A to the contact point, world oriented.\n   */\n\n  /**\n   * Relative vector from center of body B to the contact point, world oriented.\n   */\n\n  /**\n   * Tangent vector that the friction force will act along. World oriented.\n   */\n\n  /**\n   * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.\n   */\n\n  /**\n   * The shape in body i that triggered this friction.\n   * @todo Needed? The shape can be looked up via contactEquation.shapeA...\n   */\n\n  /**\n   * The shape in body j that triggered this friction.\n   * @todo Needed? The shape can be looked up via contactEquation.shapeB...\n   */\n\n  /**\n   * The friction coefficient to use.\n   */\n\n  constructor(bodyA, bodyB, slipForce) {\n    if (slipForce === void 0) {\n      slipForce = Number.MAX_VALUE;\n    }\n    super(bodyA, bodyB, -slipForce, slipForce);\n    this.contactPointA = create();\n    this.contactPointB = create();\n    this.t = create();\n    this.contactEquations = [];\n    this.shapeA = null;\n    this.shapeB = null;\n    this.frictionCoefficient = 0.3;\n  }\n\n  /**\n   * Set the slipping condition for the constraint. The friction force cannot be larger than this value.\n   * @param slipForce\n   */\n  setSlipForce(slipForce) {\n    this.maxForce = slipForce;\n    this.minForce = -slipForce;\n  }\n\n  /**\n   * Get the max force for the constraint.\n   */\n  getSlipForce() {\n    return this.maxForce;\n  }\n  computeB(a, b, h) {\n    const ri = this.contactPointA,\n      rj = this.contactPointB,\n      t = this.t,\n      G = this.G;\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    G[0] = -t[0];\n    G[1] = -t[1];\n    G[2] = -crossLength(ri, t);\n    G[3] = t[0];\n    G[4] = t[1];\n    G[5] = crossLength(rj, t);\n    const GW = this.computeGW();\n    const GiMf = this.computeGiMf();\n    const B = /* - g * a  */-GW * b - h * GiMf;\n    return B;\n  }\n}\n\nclass FrictionEquationPool extends Pool {\n  create() {\n    return new FrictionEquation(tmpBody$1, tmpBody$1);\n  }\n  destroy(equation) {\n    equation.bodyA = equation.bodyB = tmpBody$1;\n    return this;\n  }\n}\nconst tmpBody$1 = new Body();\n\nclass TupleDictionary {\n  /**\n   * The data storage\n   */\n  data = {};\n\n  /**\n   * Keys that are currently used\n   */\n  keys = [];\n\n  /**\n   * Generate a key given two integers\n   * @param i\n   * @param j\n   * @return\n   */\n  getKey(id1, id2) {\n    id1 = id1 | 0;\n    id2 = id2 | 0;\n    if ((id1 | 0) === (id2 | 0)) {\n      return -1;\n    }\n\n    // valid for values < 2^16\n    return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 0xffff : id2 << 16 | id1 & 0xffff) | 0;\n  }\n\n  /**\n   * Gets data by a given key\n   * @param key\n   * @return\n   */\n  getByKey(key) {\n    key = key | 0;\n    return this.data[key];\n  }\n\n  /**\n   * Gets a value\n   * @param i\n   * @param j\n   * @return\n   */\n  get(i, j) {\n    return this.data[this.getKey(i, j)];\n  }\n\n  /**\n   * Set a value.\n   * @param i\n   * @param j\n   * @param value\n   */\n  set(i, j, value) {\n    if (!value) {\n      throw new Error('No data!');\n    }\n    const key = this.getKey(i, j);\n\n    // Check if key already exists\n    if (!this.data[key]) {\n      this.keys.push(key);\n    }\n    this.data[key] = value;\n    return key;\n  }\n\n  /**\n   * Remove all data.\n   */\n  reset() {\n    this.keys = [];\n    this.data = {};\n  }\n\n  /**\n   * Copy another TupleDictionary. Note that all data in this dictionary will be removed.\n   * @param dict The TupleDictionary to copy into this one.\n   */\n  copy(dict) {\n    this.keys = dict.keys;\n    this.data = dict.data;\n  }\n}\n\n/**\n * Narrowphase. Creates contacts and friction given shapes and transforms.\n */\nclass Narrowphase {\n  /**\n   * Contact equations\n   */\n\n  /**\n   * Friction equations\n   */\n\n  /**\n   * Whether to make friction equations in the upcoming contacts.\n   */\n\n  /**\n   * Whether to make equations enabled in upcoming contacts.\n   */\n\n  /**\n   * The friction slip force to use when creating friction equations.\n   */\n\n  /**\n   * Keeps track of the allocated ContactEquations.\n   *\n   * @example\n   *     // Allocate a few equations before starting the simulation.\n   *     // This way, no contact objects need to be created on the fly in the game loop.\n   *     world.narrowphase.contactEquationPool.resize(1024);\n   *     world.narrowphase.frictionEquationPool.resize(1024);\n   */\n\n  /**\n   * Keeps track of the allocated ContactEquations.\n   */\n\n  /**\n   * Enable reduction of friction equations.\n   * If disabled, a box on a plane will generate 2 contact equations and 2 friction equations.\n   * If enabled, there will be only one friction equation. Same kind of simplifications are made for all collision types.\n   * @deprecated This flag will be removed when the feature is stable enough.\n   * @default true\n   */\n\n  /**\n   * Keeps track of the colliding bodies last step.\n   */\n\n  /**\n   * The current contact material\n   */\n\n  constructor() {\n    this.contactEquations = [];\n    this.frictionEquations = [];\n    this.enableFriction = true;\n    this.enabledEquations = true;\n    this.slipForce = 10.0;\n    this.contactEquationPool = new ContactEquationPool({\n      size: 32\n    });\n    this.frictionEquationPool = new FrictionEquationPool({\n      size: 64\n    });\n    this.enableFrictionReduction = true;\n    this.collidingBodiesLastStep = new TupleDictionary();\n    this.currentContactMaterial = null;\n  }\n  bodiesOverlap(bodyA, bodyB, checkCollisionMasks) {\n    const shapePositionA = bodiesOverlap_shapePositionA;\n    const shapePositionB = bodiesOverlap_shapePositionB;\n\n    // Loop over all shapes of bodyA\n    for (let k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++) {\n      const shapeA = bodyA.shapes[k];\n\n      // All shapes of body j\n      for (let l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++) {\n        const shapeB = bodyB.shapes[l];\n\n        // Check collision groups and masks\n        if (checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)) {\n          return false;\n        }\n        bodyA.toWorldFrame(shapePositionA, shapeA.position);\n        bodyB.toWorldFrame(shapePositionB, shapeB.position);\n        if (shapeA.type <= shapeB.type) {\n          if (this.narrowphases[shapeA.type | shapeB.type](bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, true)) {\n            return true;\n          }\n        } else {\n          if (this.narrowphases[shapeA.type | shapeB.type](bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, true)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the bodies were in contact since the last reset().\n   * @param bodyA\n   * @param bodyB\n   * @returns\n   */\n  collidedLastStep(bodyA, bodyB) {\n    const id1 = bodyA.id | 0;\n    const id2 = bodyB.id | 0;\n    return !!this.collidingBodiesLastStep.get(id1, id2);\n  }\n\n  /**\n   * Throws away the old equations and gets ready to create new\n   */\n  reset() {\n    this.collidingBodiesLastStep.reset();\n    const eqs = this.contactEquations;\n    let l = eqs.length;\n    while (l--) {\n      const eq = eqs[l],\n        id1 = eq.bodyA.id,\n        id2 = eq.bodyB.id;\n      this.collidingBodiesLastStep.set(id1, id2, true);\n    }\n    const ce = this.contactEquations;\n    const fe = this.frictionEquations;\n    for (let i = 0; i < ce.length; i++) {\n      this.contactEquationPool.release(ce[i]);\n    }\n    for (let i = 0; i < fe.length; i++) {\n      this.frictionEquationPool.release(fe[i]);\n    }\n\n    // Reset\n    this.contactEquations.length = this.frictionEquations.length = 0;\n  }\n\n  /**\n   * Creates a ContactEquation, either by reusing an existing object or creating a new one.\n   * @param bodyA\n   * @param bodyB\n   * @param shapeA\n   * @param shapeB\n   */\n  createContactEquation(bodyA, bodyB, shapeA, shapeB) {\n    const c = this.contactEquationPool.get();\n    const currentContactMaterial = this.currentContactMaterial;\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.enabled = this.enabledEquations;\n    c.firstImpact = !this.collidedLastStep(bodyA, bodyB);\n    c.restitution = currentContactMaterial.restitution;\n    c.stiffness = currentContactMaterial.stiffness;\n    c.relaxation = currentContactMaterial.relaxation;\n    c.offset = currentContactMaterial.contactSkinSize;\n    c.needsUpdate = true;\n    return c;\n  }\n\n  /**\n   * Creates a FrictionEquation, either by reusing an existing object or creating a new one.\n   * @param bodyA\n   * @param bodyB\n   * @param shapeA\n   * @param shapeB\n   */\n  createFrictionEquation(bodyA, bodyB, shapeA, shapeB) {\n    const c = this.frictionEquationPool.get();\n    const currentContactMaterial = this.currentContactMaterial;\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.setSlipForce(this.slipForce);\n    c.enabled = this.enabledEquations;\n    c.frictionCoefficient = currentContactMaterial.friction;\n    c.relativeVelocity = currentContactMaterial.surfaceVelocity;\n    c.stiffness = currentContactMaterial.frictionStiffness;\n    c.relaxation = currentContactMaterial.frictionRelaxation;\n    c.needsUpdate = true;\n    c.contactEquations.length = 0;\n    return c;\n  }\n\n  /**\n   * Creates a FrictionEquation given the data in the ContactEquation.\n   * Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.\n   * @param c\n   */\n  createFrictionFromContact(c) {\n    const eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    copy(eq.contactPointA, c.contactPointA);\n    copy(eq.contactPointB, c.contactPointB);\n    rotate90cw(eq.t, c.normalA);\n    eq.contactEquations.push(c);\n    return eq;\n  }\n  createFrictionFromAverage(numContacts) {\n    let c = this.contactEquations[this.contactEquations.length - 1];\n    const eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    const bodyA = c.bodyA;\n    set(eq.contactPointA, 0, 0);\n    set(eq.contactPointB, 0, 0);\n    set(eq.t, 0, 0);\n    for (let i = 0; i !== numContacts; i++) {\n      c = this.contactEquations[this.contactEquations.length - 1 - i];\n      if (c.bodyA === bodyA) {\n        add(eq.t, eq.t, c.normalA);\n        add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n        add(eq.contactPointB, eq.contactPointB, c.contactPointB);\n      } else {\n        subtract(eq.t, eq.t, c.normalA);\n        add(eq.contactPointA, eq.contactPointA, c.contactPointB);\n        add(eq.contactPointB, eq.contactPointB, c.contactPointA);\n      }\n      eq.contactEquations.push(c);\n    }\n    const invNumContacts = 1 / numContacts;\n    scale(eq.contactPointA, eq.contactPointA, invNumContacts);\n    scale(eq.contactPointB, eq.contactPointB, invNumContacts);\n    normalize(eq.t, eq.t);\n    rotate90cw(eq.t, eq.t);\n    return eq;\n  }\n\n  /**\n   * Convex/Line Narrowphase.\n   * @todo\n   * @param _convexBody\n   * @param _convexShape\n   * @param _convexOffset\n   * @param _convexAngle\n   * @param _lineBody\n   * @param _lineShape\n   * @param _lineOffset\n   * @param _lineAngle\n   * @param _justTest\n   * @returns\n   */\n  convexLine = (() => function (_convexBody, _convexShape, _convexOffset, _convexAngle, _lineBody, _lineShape, _lineOffset, _lineAngle, _justTest) {\n    return 0;\n  })();\n\n  /**\n   * Line/Box Narrowphase.\n   * @todo\n   * @param _lineBody\n   * @param _lineShape\n   * @param _lineOffset\n   * @param _lineAngle\n   * @param _boxBody\n   * @param _boxShape\n   * @param _boxOffset\n   * @param _boxAngle\n   * @param _justTest\n   * @returns\n   */\n  lineBox = (() => function (_lineBody, _lineShape, _lineOffset, _lineAngle, _boxBody, _boxShape, _boxOffset, _boxAngle, _justTest) {\n    return 0;\n  })();\n\n  /**\n   * Convex/Capsule Narrowphase.\n   * @param convexBody\n   * @param convexShape\n   * @param convexPosition\n   * @param convexAngle\n   * @param capsuleBody\n   * @param capsuleShape\n   * @param capsulePosition\n   * @param capsuleAngle\n   * @param justTest\n   * @returns\n   */\n  convexCapsule = (() => {\n    var _this = this;\n    return function (convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      // Check the circles\n      // Add offsets!\n      const circlePos = convexCapsule_tempVec;\n      const halfLength = capsuleShape.length / 2;\n      set(circlePos, halfLength, 0);\n      toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);\n      const result1 = _this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);\n      set(circlePos, -halfLength, 0);\n      toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);\n      const result2 = _this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);\n      if (justTest && result1 + result2 !== 0) {\n        return 1;\n      }\n\n      // Check center rect\n      const r = convexCapsule_tempRect;\n      setConvexToCapsuleShapeMiddle(r, capsuleShape);\n      const result = _this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);\n      return result + result1 + result2;\n    };\n  })();\n\n  /**\n   * Line/Capsule Narrowphase.\n   * @todo\n   * @param _lineBody\n   * @param _lineShape\n   * @param _linePosition\n   * @param _lineAngle\n   * @param _capsuleBody\n   * @param _capsuleShape\n   * @param _capsulePosition\n   * @param _capsuleAngle\n   * @param _justTest\n   * @returns\n   */\n  lineCapsule = (() => function (_lineBody, _lineShape, _linePosition, _lineAngle, _capsuleBody, _capsuleShape, _capsulePosition, _capsuleAngle, _justTest) {\n    return 0;\n  })();\n\n  /**\n   * Capsule/Capsule Narrowphase.\n   * @param bi\n   * @param si\n   * @param xi\n   * @param ai\n   * @param bj\n   * @param sj\n   * @param xj\n   * @param aj\n   * @param justTest\n   * @returns\n   */\n  capsuleCapsule = (() => {\n    var _this2 = this;\n    return function (bi, si, xi, ai, bj, sj, xj, aj, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      let enableFrictionBefore = true;\n\n      // Check the circles\n      // Add offsets!\n      const circlePosi = capsuleCapsule_tempVec1;\n      const circlePosj = capsuleCapsule_tempVec2;\n      let numContacts = 0;\n\n      // Need 4 circle checks, between all\n      for (let i = 0; i < 2; i++) {\n        set(circlePosi, (i === 0 ? -1 : 1) * si.length / 2, 0);\n        toGlobalFrame(circlePosi, circlePosi, xi, ai);\n        for (let j = 0; j < 2; j++) {\n          set(circlePosj, (j === 0 ? -1 : 1) * sj.length / 2, 0);\n          toGlobalFrame(circlePosj, circlePosj, xj, aj);\n\n          // Temporarily turn off friction\n          if (_this2.enableFrictionReduction) {\n            enableFrictionBefore = _this2.enableFriction;\n            _this2.enableFriction = false;\n          }\n          const result = _this2.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);\n          if (_this2.enableFrictionReduction) {\n            _this2.enableFriction = enableFrictionBefore;\n          }\n          if (justTest && result !== 0) {\n            return 1;\n          }\n          numContacts += result;\n        }\n      }\n      if (_this2.enableFrictionReduction) {\n        // Temporarily turn off friction\n        enableFrictionBefore = _this2.enableFriction;\n        _this2.enableFriction = false;\n      }\n\n      // Check circles against the center boxs\n      const rect = capsuleCapsule_tempRect1;\n      setConvexToCapsuleShapeMiddle(rect, si);\n      const result1 = _this2.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);\n      if (_this2.enableFrictionReduction) {\n        _this2.enableFriction = enableFrictionBefore;\n      }\n      if (justTest && result1 !== 0) {\n        return 1;\n      }\n      numContacts += result1;\n      if (_this2.enableFrictionReduction) {\n        // Temporarily turn off friction\n        enableFrictionBefore = _this2.enableFriction;\n        _this2.enableFriction = false;\n      }\n      setConvexToCapsuleShapeMiddle(rect, sj);\n      const result2 = _this2.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);\n      if (_this2.enableFrictionReduction) {\n        _this2.enableFriction = enableFrictionBefore;\n      }\n      if (justTest && result2 !== 0) {\n        return 1;\n      }\n      numContacts += result2;\n      if (_this2.enableFrictionReduction) {\n        if (numContacts && _this2.enableFriction) {\n          _this2.frictionEquations.push(_this2.createFrictionFromAverage(numContacts));\n        }\n      }\n      return numContacts;\n    };\n  })();\n\n  /**\n   * Line/Line Narrowphase.\n   * @todo\n   * @param _bodyA\n   * @param _shapeA\n   * @param _positionA\n   * @param _angleA\n   * @param _bodyB\n   * @param _shapeB\n   * @param _positionB\n   * @param _angleB\n   * @param _justTest\n   * @returns\n   */\n  lineLine = (() => function (_bodyA, _shapeA, _positionA, _angleA, _bodyB, _shapeB, _positionB, _angleB, _justTest) {\n    return 0;\n  })();\n\n  /**\n   * Plane/line Narrowphase\n   * @param planeBody\n   * @param planeShape\n   * @param planeOffset\n   * @param planeAngle\n   * @param lineBody\n   * @param lineShape\n   * @param lineOffset\n   * @param lineAngle\n   * @param justTest\n   * @returns\n   */\n  planeLine = (() => {\n    var _this3 = this;\n    return function (planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const worldVertex0 = tmp1;\n      const worldVertex1 = tmp2;\n      const worldVertex01 = tmp3;\n      const worldVertex11 = tmp4;\n      const worldEdge = tmp5;\n      const worldEdgeUnit = tmp6;\n      const dist = tmp7;\n      const worldNormal = tmp8;\n      const worldTangent = tmp9;\n      const verts = tmpArray;\n      let numContacts = 0;\n\n      // Get start and end points\n      set(worldVertex0, -lineShape.length / 2, 0);\n      set(worldVertex1, lineShape.length / 2, 0);\n\n      // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n      toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);\n      toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);\n      copy(worldVertex0, worldVertex01);\n      copy(worldVertex1, worldVertex11);\n\n      // Get vector along the line\n      subtract(worldEdge, worldVertex1, worldVertex0);\n      normalize(worldEdgeUnit, worldEdge);\n\n      // Get tangent to the edge.\n      rotate90cw(worldTangent, worldEdgeUnit);\n      rotate(worldNormal, yAxis$3, planeAngle);\n\n      // Check line ends\n      verts[0] = worldVertex0;\n      verts[1] = worldVertex1;\n      for (let i = 0; i < verts.length; i++) {\n        const v = verts[i];\n        subtract(dist, v, planeOffset);\n        const d = dot(dist, worldNormal);\n        if (d < 0) {\n          if (justTest) {\n            return 1;\n          }\n          const c = _this3.createContactEquation(planeBody, lineBody, planeShape, lineShape);\n          numContacts++;\n          copy(c.normalA, worldNormal);\n          normalize(c.normalA, c.normalA);\n\n          // distance vector along plane normal\n          scale(dist, worldNormal, d);\n\n          // Vector from plane center to contact\n          subtract(c.contactPointA, v, dist);\n          subtract(c.contactPointA, c.contactPointA, planeBody.position);\n\n          // From line center to contact\n          subtract(c.contactPointB, v, lineOffset);\n          add(c.contactPointB, c.contactPointB, lineOffset);\n          subtract(c.contactPointB, c.contactPointB, lineBody.position);\n          _this3.contactEquations.push(c);\n          if (!_this3.enableFrictionReduction) {\n            if (_this3.enableFriction) {\n              _this3.frictionEquations.push(_this3.createFrictionFromContact(c));\n            }\n          }\n        }\n      }\n      if (justTest) {\n        return 0;\n      }\n      if (!_this3.enableFrictionReduction) {\n        if (numContacts && _this3.enableFriction) {\n          _this3.frictionEquations.push(_this3.createFrictionFromAverage(numContacts));\n        }\n      }\n      return numContacts;\n    };\n  })();\n\n  /**\n   * Particle/Capsule Narrowphase.\n   * @param particleBody\n   * @param particleShape\n   * @param particlePosition\n   * @param particleAngle\n   * @param capsuleBody\n   * @param capsuleShape\n   * @param capsulePosition\n   * @param capsuleAngle\n   * @param justTest\n   * @returns\n   */\n  particleCapsule = (() => {\n    var _this4 = this;\n    return function (particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      return _this4.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);\n    };\n  })();\n\n  /**\n   * Circle/Line Narrowphase.\n   * @param circleBody\n   * @param circleShape\n   * @param circleOffset\n   * @param circleAngle\n   * @param lineBody\n   * @param lineShape\n   * @param lineOffset\n   * @param lineAngle\n   * @param justTest If set to true, this function will return the result (intersection or not) without adding equations.\n   * @param lineRadius Radius to add to the line. Can be used to test Capsules.\n   * @param circleRadius If set, this value overrides the circle shape radius.\n   * @returns\n   */\n  circleLine = (() => {\n    var _this5 = this;\n    return function (circleBody, circleShape, circleOffset, _circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      if (lineRadius === void 0) {\n        lineRadius = 0;\n      }\n      if (circleRadius === void 0) {\n        circleRadius = circleShape.radius;\n      }\n      const orthoDist = tmp1;\n      const lineToCircleOrthoUnit = tmp2;\n      const projectedPoint = tmp3;\n      const centerDist = tmp4;\n      const worldTangent = tmp5;\n      const worldEdge = tmp6;\n      const worldEdgeUnit = tmp7;\n      const worldVertex0 = tmp8;\n      const worldVertex1 = tmp9;\n      const worldVertex01 = tmp10;\n      const worldVertex11 = tmp11;\n      const dist = tmp12;\n      const lineToCircle = tmp13;\n      const lineEndToLineRadius = tmp14;\n      const verts = tmpArray;\n      const halfLineLength = lineShape.length / 2;\n\n      // Get start and end points\n      set(worldVertex0, -halfLineLength, 0);\n      set(worldVertex1, halfLineLength, 0);\n\n      // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n      toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);\n      toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);\n      copy(worldVertex0, worldVertex01);\n      copy(worldVertex1, worldVertex11);\n\n      // Get vector along the line\n      subtract(worldEdge, worldVertex1, worldVertex0);\n      normalize(worldEdgeUnit, worldEdge);\n\n      // Get tangent to the edge.\n      rotate90cw(worldTangent, worldEdgeUnit);\n\n      // Check distance from the plane spanned by the edge vs the circle\n      subtract(dist, circleOffset, worldVertex0);\n      const d = dot(dist, worldTangent); // Distance from center of line to circle center\n      subtract(centerDist, worldVertex0, lineOffset);\n      subtract(lineToCircle, circleOffset, lineOffset);\n      const radiusSum = circleRadius + lineRadius;\n      if (Math.abs(d) < radiusSum) {\n        // Now project the circle onto the edge\n        scale(orthoDist, worldTangent, d);\n        subtract(projectedPoint, circleOffset, orthoDist);\n\n        // Add the missing line radius\n        scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));\n        normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);\n        scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);\n        add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);\n\n        // Check if the point is within the edge span\n        const pos = dot(worldEdgeUnit, projectedPoint);\n        const pos0 = dot(worldEdgeUnit, worldVertex0);\n        const pos1 = dot(worldEdgeUnit, worldVertex1);\n        if (pos > pos0 && pos < pos1) {\n          // We got contact!\n\n          if (justTest) {\n            return 1;\n          }\n          const c = _this5.createContactEquation(circleBody, lineBody, circleShape, lineShape);\n          scale(c.normalA, orthoDist, -1);\n          normalize(c.normalA, c.normalA);\n          scale(c.contactPointA, c.normalA, circleRadius);\n          add(c.contactPointA, c.contactPointA, circleOffset);\n          subtract(c.contactPointA, c.contactPointA, circleBody.position);\n          subtract(c.contactPointB, projectedPoint, lineOffset);\n          add(c.contactPointB, c.contactPointB, lineOffset);\n          subtract(c.contactPointB, c.contactPointB, lineBody.position);\n          _this5.contactEquations.push(c);\n          if (_this5.enableFriction) {\n            _this5.frictionEquations.push(_this5.createFrictionFromContact(c));\n          }\n          return 1;\n        }\n      }\n\n      // Add corner\n      verts[0] = worldVertex0;\n      verts[1] = worldVertex1;\n      for (let i = 0; i < verts.length; i++) {\n        const v = verts[i];\n        subtract(dist, v, circleOffset);\n        if (squaredLength(dist) < Math.pow(radiusSum, 2)) {\n          if (justTest) {\n            return 1;\n          }\n          const c = _this5.createContactEquation(circleBody, lineBody, circleShape, lineShape);\n          copy(c.normalA, dist);\n          normalize(c.normalA, c.normalA);\n\n          // Vector from circle to contact point is the normal times the circle radius\n          scale(c.contactPointA, c.normalA, circleRadius);\n          add(c.contactPointA, c.contactPointA, circleOffset);\n          subtract(c.contactPointA, c.contactPointA, circleBody.position);\n          subtract(c.contactPointB, v, lineOffset);\n          scale(lineEndToLineRadius, c.normalA, -lineRadius);\n          add(c.contactPointB, c.contactPointB, lineEndToLineRadius);\n          add(c.contactPointB, c.contactPointB, lineOffset);\n          subtract(c.contactPointB, c.contactPointB, lineBody.position);\n          _this5.contactEquations.push(c);\n          if (_this5.enableFriction) {\n            _this5.frictionEquations.push(_this5.createFrictionFromContact(c));\n          }\n          return 1;\n        }\n      }\n      return 0;\n    };\n  })();\n\n  /**\n   * Circle/Capsule Narrowphase.\n   * @param bi\n   * @param si\n   * @param xi\n   * @param ai\n   * @param bj\n   * @param sj\n   * @param xj\n   * @param aj\n   * @param justTest\n   * @returns\n   */\n  circleCapsule = (() => {\n    var _this6 = this;\n    return function (bi, si, xi, ai, bj, sj, xj, aj, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      return _this6.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);\n    };\n  })();\n\n  /**\n   * Circle/Convex Narrowphase.\n   * @param circleBody\n   * @param circleShape\n   * @param circleOffset\n   * @param circleAngle\n   * @param convexBody\n   * @param convexShape\n   * @param convexOffset\n   * @param convexAngle\n   * @param justTest\n   * @param circleRadius\n   * @returns\n   */\n  circleConvex = (() => {\n    var _this7 = this;\n    return function (circleBody, circleShape, circleOffset, _circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      if (circleRadius === void 0) {\n        circleRadius = circleShape.radius;\n      }\n      const worldVertex0 = tmp1;\n      const worldVertex1 = tmp2;\n      const edge = tmp3;\n      const edgeUnit = tmp4;\n      const normal = tmp5;\n      const zero = tmp6;\n      const localCirclePosition = tmp7;\n      const r = tmp8;\n      const dist = tmp10;\n      const worldVertex = tmp11;\n      const closestEdgeProjectedPoint = tmp13;\n      const candidate = tmp14;\n      const candidateDist = tmp15;\n      let found = -1;\n      let minCandidateDistance = Number.MAX_VALUE;\n      set(zero, 0, 0);\n\n      // New algorithm:\n      // 1. Check so center of circle is not inside the polygon. If it is, this wont work...\n      // 2. For each edge\n      // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n      // 2. 2. Check if point is inside.\n\n      toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);\n      const vertices = convexShape.vertices;\n      const normals = convexShape.normals;\n      const numVertices = vertices.length;\n      let normalIndex = -1;\n\n      // Find the min separating edge.\n      let separation = -Number.MAX_VALUE;\n      const radius = convexShape.boundingRadius + circleRadius;\n      for (let i = 0; i < numVertices; i++) {\n        subtract(r, localCirclePosition, vertices[i]);\n        const s = dot(normals[i], r);\n        if (s > radius) {\n          // Early out.\n          return 0;\n        }\n        if (s > separation) {\n          separation = s;\n          normalIndex = i;\n        }\n      }\n\n      // Check edges first\n      for (let i = normalIndex + numVertices - 1; i < normalIndex + numVertices + 2; i++) {\n        const v0 = vertices[i % numVertices];\n        const n = normals[i % numVertices];\n\n        // Get point on circle, closest to the convex\n        scale(candidate, n, -circleRadius);\n        add(candidate, candidate, localCirclePosition);\n        if (pointInConvexLocal(candidate, convexShape)) {\n          subtract(candidateDist, v0, candidate);\n          const candidateDistance = Math.abs(dot(candidateDist, n));\n          if (candidateDistance < minCandidateDistance) {\n            minCandidateDistance = candidateDistance;\n            found = i;\n          }\n        }\n      }\n      if (found !== -1) {\n        if (justTest) {\n          return 1;\n        }\n        const v0 = vertices[found % numVertices];\n        const v1 = vertices[(found + 1) % numVertices];\n        toGlobalFrame(worldVertex0, v0, convexOffset, convexAngle);\n        toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);\n        subtract(edge, worldVertex1, worldVertex0);\n        normalize(edgeUnit, edge);\n\n        // Get tangent to the edge. Points out of the Convex\n        rotate90cw(normal, edgeUnit);\n\n        // Get point on circle, closest to the convex\n        scale(candidate, normal, -circleRadius);\n        add(candidate, candidate, circleOffset);\n        scale(closestEdgeProjectedPoint, normal, minCandidateDistance);\n        add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);\n        const c = _this7.createContactEquation(circleBody, convexBody, circleShape, convexShape);\n        subtract(c.normalA, candidate, circleOffset);\n        normalize(c.normalA, c.normalA);\n        scale(c.contactPointA, c.normalA, circleRadius);\n        add(c.contactPointA, c.contactPointA, circleOffset);\n        subtract(c.contactPointA, c.contactPointA, circleBody.position);\n        subtract(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        subtract(c.contactPointB, c.contactPointB, convexBody.position);\n        _this7.contactEquations.push(c);\n        if (_this7.enableFriction) {\n          _this7.frictionEquations.push(_this7.createFrictionFromContact(c));\n        }\n        return 1;\n      }\n\n      // Check closest vertices\n      if (circleRadius > 0 && normalIndex !== -1) {\n        for (let i = normalIndex + numVertices; i < normalIndex + numVertices + 2; i++) {\n          const localVertex = vertices[i % numVertices];\n          subtract(dist, localVertex, localCirclePosition);\n          if (squaredLength(dist) < circleRadius * circleRadius) {\n            if (justTest) {\n              return 1;\n            }\n            toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);\n            subtract(dist, worldVertex, circleOffset);\n            const c = _this7.createContactEquation(circleBody, convexBody, circleShape, convexShape);\n            copy(c.normalA, dist);\n            normalize(c.normalA, c.normalA);\n\n            // Vector from circle to contact point is the normal times the circle radius\n            scale(c.contactPointA, c.normalA, circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            subtract(c.contactPointA, c.contactPointA, circleBody.position);\n            subtract(c.contactPointB, worldVertex, convexOffset);\n            add(c.contactPointB, c.contactPointB, convexOffset);\n            subtract(c.contactPointB, c.contactPointB, convexBody.position);\n            _this7.contactEquations.push(c);\n            if (_this7.enableFriction) {\n              _this7.frictionEquations.push(_this7.createFrictionFromContact(c));\n            }\n            return 1;\n          }\n        }\n      }\n      return 0;\n    };\n  })();\n\n  /**\n   * Particle/Convex Narrowphase.\n   * @param particleBody\n   * @param particleShape\n   * @param particleOffset\n   * @param particleAngle\n   * @param convexBody\n   * @param convexShape\n   * @param convexOffset\n   * @param convexAngle\n   * @param justTest\n   * @returns\n   */\n  particleConvex = (() => {\n    var _this8 = this;\n    return function (particleBody, particleShape, particleOffset, _particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const worldVertex0 = tmp1;\n      const worldVertex1 = tmp2;\n      const worldEdge = tmp3;\n      const worldEdgeUnit = tmp4;\n      const worldTangent = tmp5;\n      const centerDist = tmp6;\n      const convexToparticle = tmp7;\n      const closestEdgeProjectedPoint = tmp13;\n      const candidateDist = tmp14;\n      const minEdgeNormal = tmp15;\n      const verts = convexShape.vertices;\n      let minCandidateDistance = Number.MAX_VALUE;\n      let found = false;\n\n      // Check if the particle is in the polygon at all\n      if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {\n        return 0;\n      }\n      if (justTest) {\n        return 1;\n      }\n\n      // Check edges first\n      for (let i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {\n        const v0 = verts[i % numVerts],\n          v1 = verts[(i + 1) % numVerts];\n\n        // Transform vertices to world\n        // @todo transform point to local space instead\n        rotate(worldVertex0, v0, convexAngle);\n        rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        // Get world edge\n        subtract(worldEdge, worldVertex1, worldVertex0);\n        normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        rotate90cw(worldTangent, worldEdgeUnit);\n\n        // Check distance from the infinite line (spanned by the edge) to the particle\n        subtract(centerDist, worldVertex0, convexOffset);\n        subtract(convexToparticle, particleOffset, convexOffset);\n        subtract(candidateDist, worldVertex0, particleOffset);\n        const candidateDistance = Math.abs(dot(candidateDist, worldTangent));\n        if (candidateDistance < minCandidateDistance) {\n          minCandidateDistance = candidateDistance;\n          scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);\n          add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);\n          copy(minEdgeNormal, worldTangent);\n          found = true;\n        }\n      }\n      if (found) {\n        const c = _this8.createContactEquation(particleBody, convexBody, particleShape, convexShape);\n        scale(c.normalA, minEdgeNormal, -1);\n        normalize(c.normalA, c.normalA);\n\n        // Particle has no extent to the contact point\n        set(c.contactPointA, 0, 0);\n        add(c.contactPointA, c.contactPointA, particleOffset);\n        subtract(c.contactPointA, c.contactPointA, particleBody.position);\n\n        // From convex center to point\n        subtract(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        subtract(c.contactPointB, c.contactPointB, convexBody.position);\n        _this8.contactEquations.push(c);\n        if (_this8.enableFriction) {\n          _this8.frictionEquations.push(_this8.createFrictionFromContact(c));\n        }\n        return 1;\n      }\n      return 0;\n    };\n  })();\n\n  /**\n   * Circle/Circle Narrowphase.\n   * @param bodyA\n   * @param shapeA\n   * @param offsetA\n   * @param angleA\n   * @param bodyB\n   * @param shapeB\n   * @param offsetB\n   * @param angleB\n   * @param justTest\n   * @param radiusA\n   * @param radiusB\n   * @returns\n   */\n  circleCircle = (() => {\n    var _this9 = this;\n    return function (bodyA, shapeA, offsetA, _angleA, bodyB, shapeB, offsetB, _angleB, justTest, radiusA, radiusB) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      if (radiusA === void 0) {\n        radiusA = shapeA.radius;\n      }\n      if (radiusB === void 0) {\n        radiusB = shapeB.radius;\n      }\n      const dist = tmp1;\n      subtract(dist, offsetA, offsetB);\n      const r = radiusA + radiusB;\n      if (squaredLength(dist) > r * r) {\n        return 0;\n      }\n      if (justTest) {\n        return 1;\n      }\n      const c = _this9.createContactEquation(bodyA, bodyB, shapeA, shapeB);\n      const cpA = c.contactPointA;\n      const cpB = c.contactPointB;\n      const normalA = c.normalA;\n      subtract(normalA, offsetB, offsetA);\n      normalize(normalA, normalA);\n      scale(cpA, normalA, radiusA);\n      scale(cpB, normalA, -radiusB);\n      addsubtract(cpA, cpA, offsetA, bodyA.position);\n      addsubtract(cpB, cpB, offsetB, bodyB.position);\n      _this9.contactEquations.push(c);\n      if (_this9.enableFriction) {\n        _this9.frictionEquations.push(_this9.createFrictionFromContact(c));\n      }\n      return 1;\n    };\n  })();\n\n  /**\n   * Plane/Convex Narrowphase.\n   * @param planeBody\n   * @param planeShape\n   * @param planeOffset\n   * @param planeAngle\n   * @param convexBody\n   * @param convexShape\n   * @param convexOffset\n   * @param convexAngle\n   * @param justTest\n   * @returns\n   * @todo only use the deepest contact point + the contact point furthest away from it\n   */\n  planeConvex = (() => {\n    var _this10 = this;\n    return function (planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const worldVertex = tmp1;\n      const worldNormal = tmp2;\n      const dist = tmp3;\n      const localPlaneOffset = tmp4;\n      const localPlaneNormal = tmp5;\n      const localDist = tmp6;\n      let numReported = 0;\n      rotate(worldNormal, yAxis$3, planeAngle);\n\n      // Get convex-local plane offset and normal\n      vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);\n      toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);\n      const vertices = convexShape.vertices;\n      for (let i = 0, numVerts = vertices.length; i !== numVerts; i++) {\n        const v = vertices[i];\n        subtract(localDist, v, localPlaneOffset);\n        if (dot(localDist, localPlaneNormal) <= 0) {\n          if (justTest) {\n            return 1;\n          }\n          toGlobalFrame(worldVertex, v, convexOffset, convexAngle);\n          subtract(dist, worldVertex, planeOffset);\n\n          // Found vertex\n          numReported++;\n          const c = _this10.createContactEquation(planeBody, convexBody, planeShape, convexShape);\n          subtract(dist, worldVertex, planeOffset);\n          copy(c.normalA, worldNormal);\n          const d = dot(dist, c.normalA);\n          scale(dist, c.normalA, d);\n\n          // rj is from convex center to contact\n          subtract(c.contactPointB, worldVertex, convexBody.position);\n\n          // ri is from plane center to contact\n          subtract(c.contactPointA, worldVertex, dist);\n          subtract(c.contactPointA, c.contactPointA, planeBody.position);\n          _this10.contactEquations.push(c);\n          if (!_this10.enableFrictionReduction) {\n            if (_this10.enableFriction) {\n              _this10.frictionEquations.push(_this10.createFrictionFromContact(c));\n            }\n          }\n        }\n      }\n      if (_this10.enableFrictionReduction) {\n        if (_this10.enableFriction && numReported) {\n          _this10.frictionEquations.push(_this10.createFrictionFromAverage(numReported));\n        }\n      }\n      return numReported;\n    };\n  })();\n\n  /**\n   * Particle/Plane Narrowphase.\n   * @param particleBody\n   * @param particleShape\n   * @param particleOffset\n   * @param particleAngle\n   * @param planeBody\n   * @param planeShape\n   * @param planeOffset\n   * @param planeAngle\n   * @param justTest\n   * @returns\n   */\n  particlePlane = (() => {\n    var _this11 = this;\n    return function (particleBody, particleShape, particleOffset, _particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const dist = tmp1;\n      const worldNormal = tmp2;\n      planeAngle = planeAngle || 0;\n      subtract(dist, particleOffset, planeOffset);\n      rotate(worldNormal, yAxis$3, planeAngle);\n      const d = dot(dist, worldNormal);\n      if (d > 0) {\n        return 0;\n      }\n      if (justTest) {\n        return 1;\n      }\n      const c = _this11.createContactEquation(planeBody, particleBody, planeShape, particleShape);\n      copy(c.normalA, worldNormal);\n      scale(dist, c.normalA, d);\n      // dist is now the distance vector in the normal direction\n\n      // ri is the particle position projected down onto the plane, from the plane center\n      subtract(c.contactPointA, particleOffset, dist);\n      subtract(c.contactPointA, c.contactPointA, planeBody.position);\n\n      // rj is from the body center to the particle center\n      subtract(c.contactPointB, particleOffset, particleBody.position);\n      _this11.contactEquations.push(c);\n      if (_this11.enableFriction) {\n        _this11.frictionEquations.push(_this11.createFrictionFromContact(c));\n      }\n      return 1;\n    };\n  })();\n  circleParticle = (() => {\n    var _this12 = this;\n    return function (circleBody, circleShape, circleOffset, _circleAngle, particleBody, particleShape, particleOffset, _particleAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const dist = tmp1;\n      const circleRadius = circleShape.radius;\n      subtract(dist, particleOffset, circleOffset);\n      if (squaredLength(dist) > circleRadius * circleRadius) {\n        return 0;\n      }\n      if (justTest) {\n        return 1;\n      }\n      const c = _this12.createContactEquation(circleBody, particleBody, circleShape, particleShape);\n      const normalA = c.normalA;\n      const contactPointA = c.contactPointA;\n      const contactPointB = c.contactPointB;\n      copy(normalA, dist);\n      normalize(normalA, normalA);\n\n      // Vector from circle to contact point is the normal times the circle radius\n      scale(contactPointA, normalA, circleRadius);\n      add(contactPointA, contactPointA, circleOffset);\n      subtract(contactPointA, contactPointA, circleBody.position);\n\n      // Vector from particle center to contact point is zero\n      subtract(contactPointB, particleOffset, particleBody.position);\n      _this12.contactEquations.push(c);\n      if (_this12.enableFriction) {\n        _this12.frictionEquations.push(_this12.createFrictionFromContact(c));\n      }\n      return 1;\n    };\n  })();\n\n  /**\n   * Plane/Capsule Narrowphase.\n   * @param planeBody\n   * @param planeShape\n   * @param planeOffset\n   * @param planeAngle\n   * @param capsuleBody\n   * @param capsuleShape\n   * @param capsuleOffset\n   * @param capsuleAngle\n   * @param justTest\n   * @returns\n   */\n  planeCapsule = (() => {\n    var _this13 = this;\n    return function (planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const end1 = planeCapsule_tmp1;\n      const end2 = planeCapsule_tmp2;\n      const circle = planeCapsule_tmpCircle;\n      const halfLength = capsuleShape.length / 2;\n\n      // Compute world end positions\n      set(end1, -halfLength, 0);\n      set(end2, halfLength, 0);\n      toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);\n      toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);\n      circle.radius = capsuleShape.radius;\n      let enableFrictionBefore = true;\n\n      // Temporarily turn off friction\n      if (_this13.enableFrictionReduction) {\n        enableFrictionBefore = _this13.enableFriction;\n        _this13.enableFriction = false;\n      }\n\n      // Do Narrowphase as two circles\n      const numContacts1 = _this13.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest),\n        numContacts2 = _this13.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);\n\n      // Restore friction\n      if (_this13.enableFrictionReduction) {\n        _this13.enableFriction = enableFrictionBefore;\n      }\n      if (justTest) {\n        return numContacts1 + numContacts2;\n      } else {\n        const numTotal = numContacts1 + numContacts2;\n        if (_this13.enableFrictionReduction) {\n          if (numTotal) {\n            _this13.frictionEquations.push(_this13.createFrictionFromAverage(numTotal));\n          }\n        }\n        return numTotal;\n      }\n    };\n  })();\n\n  /**\n   * Circle/Plane Narrowphase\n   * @param circleBody\n   * @param circleShape\n   * @param circleOffset\n   * @param circleAngle\n   * @param planeBody\n   * @param planeShape\n   * @param planeOffset\n   * @param planeAngle\n   * @param justTest\n   * @returns\n   */\n  circlePlane = (() => {\n    var _this14 = this;\n    return function (circleBody, circleShape, circleOffset, _circleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const circleRadius = circleShape.radius;\n\n      // Vector from plane to circle\n      const planeToCircle = tmp1,\n        worldNormal = tmp2,\n        temp = tmp3;\n      subtract(planeToCircle, circleOffset, planeOffset);\n\n      // World plane normal\n      rotate(worldNormal, yAxis$3, planeAngle);\n\n      // Normal direction distance\n      const d = dot(worldNormal, planeToCircle);\n      if (d > circleRadius) {\n        return 0; // No overlap. Abort.\n      }\n\n      if (justTest) {\n        return 1;\n      }\n\n      // Create contact\n      const contact = _this14.createContactEquation(planeBody, circleBody, planeShape, circleShape);\n\n      // ni is the plane world normal\n      copy(contact.normalA, worldNormal);\n\n      // rj is the vector from circle center to the contact point\n      const cpB = contact.contactPointB;\n      scale(cpB, contact.normalA, -circleRadius);\n      add(cpB, cpB, circleOffset);\n      subtract(cpB, cpB, circleBody.position);\n\n      // ri is the distance from plane center to contact.\n      const cpA = contact.contactPointA;\n      scale(temp, contact.normalA, d);\n      subtract(cpA, planeToCircle, temp); // Subtract normal distance vector from the distance vector\n      add(cpA, cpA, planeOffset);\n      subtract(cpA, cpA, planeBody.position);\n      _this14.contactEquations.push(contact);\n      if (_this14.enableFriction) {\n        _this14.frictionEquations.push(_this14.createFrictionFromContact(contact));\n      }\n      return 1;\n    };\n  })();\n\n  /**\n   * Convex/Convex Narrowphase.\n   *\n   * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n   *\n   * @param bodyA\n   * @param polyA\n   * @param positionA\n   * @param angleA\n   * @param bodyB\n   * @param polyB\n   * @param positionB\n   * @param angleB\n   * @param justTest\n   * @returns\n   */\n  convexConvex = (() => {\n    var _this15 = this;\n    return function (bodyA, polyA, positionA, angleA, bodyB, polyB, positionB, angleB, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const totalRadius = 0;\n      const dist = convexConvex_dist;\n      const tempVec = convexConvex_tempVec;\n      const tmpVec = convexConvex_tmpVec;\n      const edgeA = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);\n      const separationA = tempVec[0];\n      if (separationA > totalRadius) {\n        return 0;\n      }\n      const edgeB = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);\n      const separationB = tmpVec[0];\n      if (separationB > totalRadius) {\n        return 0;\n      }\n      let poly1; // reference polygon\n      let poly2; // incident polygon\n\n      let position1;\n      let position2;\n      let angle1;\n      let angle2;\n      let body1;\n      let body2;\n      let edge1; // reference edge\n\n      if (separationB > separationA) {\n        poly1 = polyB;\n        poly2 = polyA;\n        body1 = bodyB;\n        body2 = bodyA;\n        position1 = positionB;\n        angle1 = angleB;\n        position2 = positionA;\n        angle2 = angleA;\n        edge1 = edgeB;\n      } else {\n        poly1 = polyA;\n        poly2 = polyB;\n        body1 = bodyA;\n        body2 = bodyB;\n        position1 = positionA;\n        angle1 = angleA;\n        position2 = positionB;\n        angle2 = angleB;\n        edge1 = edgeA;\n      }\n      const incidentEdge = convexConvex_incidentEdge;\n      findIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);\n      const count1 = poly1.vertices.length;\n      const vertices1 = poly1.vertices;\n      const iv1 = edge1;\n      const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n      const v11 = convexConvex_v11;\n      const v12 = convexConvex_v12;\n      copy(v11, vertices1[iv1]);\n      copy(v12, vertices1[iv2]);\n      const localTangent = convexConvex_localTangent;\n      subtract(localTangent, v12, v11);\n      normalize(localTangent, localTangent);\n      const localNormal = convexConvex_localNormal;\n      crossVZ(localNormal, localTangent, 1.0);\n      const planePoint = convexConvex_planePoint;\n      add(planePoint, v11, v12);\n      scale(planePoint, planePoint, 0.5);\n      const tangent = convexConvex_tangent; // tangent in world space\n      rotate(tangent, localTangent, angle1);\n      const normal = convexConvex_normal; // normal in world space\n      crossVZ(normal, tangent, 1.0);\n      toGlobalFrame(v11, v11, position1, angle1);\n      toGlobalFrame(v12, v12, position1, angle1);\n\n      // Face offset.\n      const frontOffset = dot(normal, v11);\n\n      // Side offsets, extended by polytope skin thickness.\n      const sideOffset1 = -dot(tangent, v11) + totalRadius;\n      const sideOffset2 = dot(tangent, v12) + totalRadius;\n\n      // Clip incident edge against extruded edge1 side edges.\n      const clipPoints1 = convexConvex_clipPoints1;\n      const clipPoints2 = convexConvex_clipPoints2;\n      let np = 0;\n\n      // Clip to box side 1\n      const negativeTangent = convexConvex_negativeTangent;\n      scale(negativeTangent, tangent, -1);\n      np = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1);\n      if (np < 2) {\n        return 0;\n      }\n\n      // Clip to negative box side 1\n      np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);\n      if (np < 2) {\n        return 0;\n      }\n      let pointCount = 0;\n      for (let i = 0; i < maxManifoldPoints; ++i) {\n        const separation = dot(normal, clipPoints2[i]) - frontOffset;\n        if (separation <= totalRadius) {\n          if (justTest) {\n            return 1;\n          }\n          ++pointCount;\n          const c = _this15.createContactEquation(body1, body2, poly1, poly2);\n          copy(c.normalA, normal);\n          copy(c.contactPointB, clipPoints2[i]);\n          subtract(c.contactPointB, c.contactPointB, body2.position);\n          scale(dist, normal, -separation);\n          add(c.contactPointA, clipPoints2[i], dist);\n          subtract(c.contactPointA, c.contactPointA, body1.position);\n          _this15.contactEquations.push(c);\n          if (_this15.enableFriction && !_this15.enableFrictionReduction) {\n            _this15.frictionEquations.push(_this15.createFrictionFromContact(c));\n          }\n        }\n      }\n      if (pointCount && _this15.enableFrictionReduction && _this15.enableFriction) {\n        _this15.frictionEquations.push(_this15.createFrictionFromAverage(pointCount));\n      }\n      return pointCount;\n    };\n  })();\n\n  /**\n   * Circle/Heightfield Narrowphase.\n   * @param circleBody\n   * @param circleShape\n   * @param circlePos\n   * @param circleAngle\n   * @param hfBody\n   * @param hfShape\n   * @param hfPos\n   * @param hfAngle\n   * @param justTest\n   * @param radius\n   * @returns\n   */\n  circleHeightfield = (() => {\n    var _this16 = this;\n    return function (circleBody, circleShape, circlePos, _circleAngle, hfBody, hfShape, hfPos, _fAngle, justTest, radius) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      if (radius === void 0) {\n        radius = circleShape.radius;\n      }\n      const data = hfShape.heights;\n      const w = hfShape.elementWidth;\n      const dist = circleHeightfield_dist;\n      const candidate = circleHeightfield_candidate;\n      const minCandidate = circleHeightfield_minCandidate;\n      const minCandidateNormal = circleHeightfield_minCandidateNormal;\n      const worldNormal = circleHeightfield_worldNormal;\n      const v0 = circleHeightfield_v0;\n      const v1 = circleHeightfield_v1;\n\n      // Get the index of the points to test against\n      let idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w),\n        idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);\n\n      /*if(idxB < 0 || idxA >= data.length)\n          return justTest ? false : 0;*/\n\n      if (idxA < 0) {\n        idxA = 0;\n      }\n      if (idxB >= data.length) {\n        idxB = data.length - 1;\n      }\n\n      // Get max and min\n      let max = data[idxA],\n        min = data[idxB];\n      for (let i = idxA; i < idxB; i++) {\n        if (data[i] < min) {\n          min = data[i];\n        }\n        if (data[i] > max) {\n          max = data[i];\n        }\n      }\n      if (circlePos[1] - radius > max) {\n        return 0;\n      }\n\n      /*\n      if(circlePos[1]+radius < min){\n          // Below the minimum point... We can just guess.\n          // TODO\n      }\n      */\n\n      // 1. Check so center of circle is not inside the field. If it is, this wont work...\n      // 2. For each edge\n      // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n      // 2. 2. Check if point is inside.\n\n      let found = false;\n\n      // Check all edges first\n      for (let i = idxA; i < idxB; i++) {\n        // Get points\n        set(v0, i * w, data[i]);\n        set(v1, (i + 1) * w, data[i + 1]);\n        add(v0, v0, hfPos); // @todo transform circle to local heightfield space instead\n        add(v1, v1, hfPos);\n\n        // Get normal\n        subtract(worldNormal, v1, v0);\n        rotate(worldNormal, worldNormal, Math.PI / 2);\n        normalize(worldNormal, worldNormal);\n\n        // Get point on circle, closest to the edge\n        scale(candidate, worldNormal, -radius);\n        add(candidate, candidate, circlePos);\n\n        // Distance from v0 to the candidate point\n        subtract(dist, candidate, v0);\n\n        // Check if it is in the element \"stick\"\n        const d = dot(dist, worldNormal);\n        if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {\n          if (justTest) {\n            return 1;\n          }\n          found = true;\n\n          // Store the candidate point, projected to the edge\n          scale(dist, worldNormal, -d);\n          add(minCandidate, candidate, dist);\n          copy(minCandidateNormal, worldNormal);\n          const c = _this16.createContactEquation(hfBody, circleBody, hfShape, circleShape);\n\n          // Normal is out of the heightfield\n          copy(c.normalA, minCandidateNormal);\n\n          // Vector from circle to heightfield\n          scale(c.contactPointB, c.normalA, -radius);\n          add(c.contactPointB, c.contactPointB, circlePos);\n          subtract(c.contactPointB, c.contactPointB, circleBody.position);\n          copy(c.contactPointA, minCandidate);\n          subtract(c.contactPointA, c.contactPointA, hfBody.position);\n          _this16.contactEquations.push(c);\n          if (_this16.enableFriction) {\n            _this16.frictionEquations.push(_this16.createFrictionFromContact(c));\n          }\n        }\n      }\n\n      // Check all vertices\n      found = false;\n      if (radius > 0) {\n        for (let i = idxA; i <= idxB; i++) {\n          // Get point\n          set(v0, i * w, data[i]);\n          add(v0, v0, hfPos);\n          subtract(dist, circlePos, v0);\n          if (squaredLength(dist) < Math.pow(radius, 2)) {\n            if (justTest) {\n              return 1;\n            }\n            found = true;\n            const c = _this16.createContactEquation(hfBody, circleBody, hfShape, circleShape);\n\n            // Construct normal - out of heightfield\n            copy(c.normalA, dist);\n            normalize(c.normalA, c.normalA);\n            scale(c.contactPointB, c.normalA, -radius);\n            add(c.contactPointB, c.contactPointB, circlePos);\n            subtract(c.contactPointB, c.contactPointB, circleBody.position);\n            subtract(c.contactPointA, v0, hfPos);\n            add(c.contactPointA, c.contactPointA, hfPos);\n            subtract(c.contactPointA, c.contactPointA, hfBody.position);\n            _this16.contactEquations.push(c);\n            if (_this16.enableFriction) {\n              _this16.frictionEquations.push(_this16.createFrictionFromContact(c));\n            }\n          }\n        }\n      }\n      if (found) {\n        return 1;\n      }\n      return 0;\n    };\n  })();\n\n  /**\n   * Convex/Heightfield Narrowphase.\n   * @param convexBody\n   * @param convexShape\n   * @param convexPos\n   * @param convexAngle\n   * @param hfBody\n   * @param hfShape\n   * @param hfPos\n   * @param hfAngle\n   * @param justTest\n   * @returns\n   */\n  convexHeightfield = (() => {\n    var _this17 = this;\n    return function (convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, _hfAngle, justTest) {\n      if (justTest === void 0) {\n        justTest = false;\n      }\n      const data = hfShape.heights,\n        w = hfShape.elementWidth,\n        v0 = convexHeightfield_v0,\n        v1 = convexHeightfield_v1,\n        tilePos = convexHeightfield_tilePos,\n        tileConvex = convexHeightfield_tempConvexShape;\n\n      // Get the index of the points to test against\n      let idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w),\n        idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);\n      if (idxA < 0) {\n        idxA = 0;\n      }\n      if (idxB >= data.length) {\n        idxB = data.length - 1;\n      }\n\n      // Get max and min\n      let max = data[idxA],\n        min = data[idxB];\n      for (let i = idxA; i < idxB; i++) {\n        if (data[i] < min) {\n          min = data[i];\n        }\n        if (data[i] > max) {\n          max = data[i];\n        }\n      }\n      if (convexBody.aabb.lowerBound[1] > max) {\n        return 0;\n      }\n      let numContacts = 0;\n\n      // Loop over all edges\n      // @todo If possible, construct a convex from several data points (need o check if the points make a convex shape)\n      // @todo transform convex to local heightfield space.\n      // @todo bail out if the heightfield tile is not tall enough.\n      for (let i = idxA; i < idxB; i++) {\n        // Get points\n        set(v0, i * w, data[i]);\n        set(v1, (i + 1) * w, data[i + 1]);\n        add(v0, v0, hfPos);\n        add(v1, v1, hfPos);\n\n        // Construct a convex\n        const tileHeight = 100; // todo\n        set(tilePos, (v1[0] + v0[0]) * 0.5, (v1[1] + v0[1] - tileHeight) * 0.5);\n        subtract(tileConvex.vertices[0], v1, tilePos);\n        subtract(tileConvex.vertices[1], v0, tilePos);\n        copy(tileConvex.vertices[2], tileConvex.vertices[1]);\n        copy(tileConvex.vertices[3], tileConvex.vertices[0]);\n        tileConvex.vertices[2][1] -= tileHeight;\n        tileConvex.vertices[3][1] -= tileHeight;\n        tileConvex.updateNormals();\n\n        // Do convex collision\n        numContacts += _this17.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);\n      }\n      return numContacts;\n    };\n  })();\n  narrowphases = {\n    [Shape.CONVEX | Shape.LINE]: this.convexLine,\n    [Shape.LINE | Shape.BOX]: this.lineBox,\n    [Shape.CONVEX | Shape.CAPSULE]: this.convexCapsule,\n    [Shape.BOX | Shape.CAPSULE]: this.convexCapsule,\n    [Shape.LINE | Shape.CAPSULE]: this.lineCapsule,\n    [Shape.CAPSULE]: this.capsuleCapsule,\n    [Shape.LINE]: this.lineLine,\n    [Shape.PLANE | Shape.LINE]: this.planeLine,\n    [Shape.PARTICLE | Shape.CAPSULE]: this.particleCapsule,\n    [Shape.CIRCLE | Shape.LINE]: this.circleLine,\n    [Shape.CIRCLE | Shape.CAPSULE]: this.circleCapsule,\n    [Shape.CIRCLE | Shape.CONVEX]: this.circleConvex,\n    [Shape.CIRCLE | Shape.BOX]: this.circleConvex,\n    [Shape.PARTICLE | Shape.CONVEX]: this.particleConvex,\n    [Shape.PARTICLE | Shape.BOX]: this.particleConvex,\n    [Shape.CIRCLE]: this.circleCircle,\n    [Shape.PLANE | Shape.CONVEX]: this.planeConvex,\n    [Shape.PLANE | Shape.BOX]: this.planeConvex,\n    [Shape.PARTICLE | Shape.PLANE]: this.particlePlane,\n    [Shape.CIRCLE | Shape.PARTICLE]: this.circleParticle,\n    [Shape.PLANE | Shape.CAPSULE]: this.planeCapsule,\n    [Shape.CIRCLE | Shape.PLANE]: this.circlePlane,\n    [Shape.CONVEX]: this.convexConvex,\n    [Shape.CONVEX | Shape.BOX]: this.convexConvex,\n    [Shape.BOX]: this.convexConvex,\n    [Shape.CIRCLE | Shape.HEIGHTFIELD]: this.circleHeightfield,\n    [Shape.BOX | Shape.HEIGHTFIELD]: this.convexHeightfield,\n    [Shape.CONVEX | Shape.HEIGHTFIELD]: this.convexHeightfield\n  };\n}\n\n// Temp things\nconst yAxis$3 = fromValues(0, 1);\nconst tmp1 = create();\nconst tmp2 = create();\nconst tmp3 = create();\nconst tmp4 = create();\nconst tmp5 = create();\nconst tmp6 = create();\nconst tmp7 = create();\nconst tmp8 = create();\nconst tmp9 = create();\nconst tmp10 = create();\nconst tmp11 = create();\nconst tmp12 = create();\nconst tmp13 = create();\nconst tmp14 = create();\nconst tmp15 = create();\nconst tmpArray = [];\nconst bodiesOverlap_shapePositionA = create();\nconst bodiesOverlap_shapePositionB = create();\nconst convexConvex_tempVec = create();\nconst convexConvex_tmpVec = create();\nconst convexConvex_localTangent = create();\nconst convexConvex_localNormal = create();\nconst convexConvex_planePoint = create();\nconst convexConvex_tangent = create();\nconst convexConvex_normal = create();\nconst convexConvex_negativeTangent = create();\nconst convexConvex_v11 = create();\nconst convexConvex_v12 = create();\nconst convexConvex_dist = create();\nconst convexConvex_clipPoints1 = [create(), create()];\nconst convexConvex_clipPoints2 = [create(), create()];\nconst convexConvex_incidentEdge = [create(), create()];\nconst maxManifoldPoints = 2;\nconst circleHeightfield_candidate = create();\nconst circleHeightfield_dist = create();\nconst circleHeightfield_v0 = create();\nconst circleHeightfield_v1 = create();\nconst circleHeightfield_minCandidate = create();\nconst circleHeightfield_worldNormal = create();\nconst circleHeightfield_minCandidateNormal = create();\nfunction setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {\n  const capsuleRadius = capsuleShape.radius;\n  const halfCapsuleLength = capsuleShape.length * 0.5;\n  const verts = convexShape.vertices;\n  set(verts[0], -halfCapsuleLength, -capsuleRadius);\n  set(verts[1], halfCapsuleLength, -capsuleRadius);\n  set(verts[2], halfCapsuleLength, capsuleRadius);\n  set(verts[3], -halfCapsuleLength, capsuleRadius);\n}\nconst convexCapsule_tempRect = new Box({\n  width: 1,\n  height: 1\n});\nconst convexCapsule_tempVec = create();\nconst capsuleCapsule_tempVec1 = create();\nconst capsuleCapsule_tempVec2 = create();\nconst capsuleCapsule_tempRect1 = new Box({\n  width: 1,\n  height: 1\n});\nconst pointInConvex_localPoint = create();\nconst pointInConvex_r0 = create();\nconst pointInConvex_r1 = create();\n\n/*\n * Check if a point is in a polygon\n */\nfunction pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {\n  const localPoint = pointInConvex_localPoint;\n  const r0 = pointInConvex_r0;\n  const r1 = pointInConvex_r1;\n  const verts = convexShape.vertices;\n  let lastCross = null;\n  toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);\n  for (let i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {\n    const v0 = verts[i % numVerts],\n      v1 = verts[(i + 1) % numVerts];\n    subtract(r0, v0, localPoint);\n    subtract(r1, v1, localPoint);\n    const cross = crossLength(r0, r1);\n    if (lastCross === null) {\n      lastCross = cross;\n    }\n\n    // If we got a different sign of the distance vector, the point is out of the polygon\n    if (cross * lastCross < 0) {\n      return false;\n    }\n    lastCross = cross;\n  }\n  return true;\n}\nfunction addsubtract(out, a, b, c) {\n  out[0] = a[0] + b[0] - c[0];\n  out[1] = a[1] + b[1] - c[1];\n}\n\n/*\n * Check if a point is in a polygon\n */\nfunction pointInConvexLocal(localPoint, convexShape) {\n  const r0 = pointInConvex_r0;\n  const r1 = pointInConvex_r1;\n  const verts = convexShape.vertices;\n  const numVerts = verts.length;\n  let lastCross = null;\n  for (let i = 0; i < numVerts + 1; i++) {\n    const v0 = verts[i % numVerts],\n      v1 = verts[(i + 1) % numVerts];\n    subtract(r0, v0, localPoint);\n    subtract(r1, v1, localPoint);\n    const cross = crossLength(r0, r1);\n    if (lastCross === null) {\n      lastCross = cross;\n    }\n\n    // If we got a different sign of the distance vector, the point is out of the polygon\n    if (cross * lastCross < 0) {\n      return false;\n    }\n    lastCross = cross;\n  }\n  return true;\n}\nconst planeCapsule_tmpCircle = new Circle({\n  radius: 1\n});\nconst planeCapsule_tmp1 = create();\nconst planeCapsule_tmp2 = create();\n\n// Find the max separation between poly1 and poly2 using edge normals from poly1.\nconst findMaxSeparation_n = create();\nconst findMaxSeparation_v1 = create();\nconst findMaxSeparation_tmp = create();\nconst findMaxSeparation_tmp2 = create();\nfunction findMaxSeparation(maxSeparationOut, poly1, position1, angle1, poly2, position2, angle2) {\n  const count1 = poly1.vertices.length;\n  const count2 = poly2.vertices.length;\n  const n1s = poly1.normals;\n  const v1s = poly1.vertices;\n  const v2s = poly2.vertices;\n  const n = findMaxSeparation_n;\n  const v1 = findMaxSeparation_v1;\n  const tmp = findMaxSeparation_tmp;\n  const tmp2 = findMaxSeparation_tmp2;\n  const angle = angle1 - angle2;\n  let bestIndex = 0;\n  let maxSeparation = -Number.MAX_VALUE;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    rotate(n, n1s[i], angle);\n\n    // Get poly1 vertex in frame2\n    toGlobalFrame(tmp2, v1s[i], position1, angle1);\n    toLocalFrame(v1, tmp2, position2, angle2);\n\n    // Find deepest point for normal i.\n    let si = Number.MAX_VALUE;\n    for (let j = 0; j < count2; ++j) {\n      subtract(tmp, v2s[j], v1);\n      const sij = dot(n, tmp);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // Use a vec2 for storing the float value and always return int, for perf\n  maxSeparationOut[0] = maxSeparation;\n  return bestIndex;\n}\nconst findIncidentEdge_normal1 = create();\nfunction findIncidentEdge(clipVerticesOut, poly1, position1, angle1, edge1, poly2, position2, angle2) {\n  const normals1 = poly1.normals;\n  const count2 = poly2.vertices.length;\n  const vertices2 = poly2.vertices;\n  const normals2 = poly2.normals;\n\n  // Get the normal of the reference edge in poly2's frame.\n  const normal1 = findIncidentEdge_normal1;\n  rotate(normal1, normals1[edge1], angle1 - angle2);\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Number.MAX_VALUE;\n  for (let i = 0; i < count2; ++i) {\n    const dot$1 = dot(normal1, normals2[i]);\n    if (dot$1 < minDot) {\n      minDot = dot$1;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n  toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);\n  toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);\n}\nfunction clipSegmentToLine(vOut, vIn, normal, offset) {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = dot(normal, vIn[0]) - offset;\n  const distance1 = dot(normal, vIn[1]) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0) {\n    copy(vOut[numOut++], vIn[0]);\n  }\n  if (distance1 <= 0.0) {\n    copy(vOut[numOut++], vIn[1]);\n  }\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    const v = vOut[numOut];\n    subtract(v, vIn[1], vIn[0]);\n    scale(v, v, interp);\n    add(v, v, vIn[0]);\n    ++numOut;\n  }\n  return numOut;\n}\nconst convexHeightfield_v0 = create();\nconst convexHeightfield_v1 = create();\nconst convexHeightfield_tilePos = create();\nconst convexHeightfield_tempConvexShape = new Convex({\n  vertices: [create(), create(), create(), create()]\n});\n\n/**\n * Sweep and prune broadphase along one axis.\n */\nclass SAPBroadphase extends Broadphase {\n  /**\n   * List of bodies currently in the broadphase.\n   */\n  axisList = [];\n  axisIndex = 0;\n  constructor() {\n    super(Broadphase.SAP);\n    this.addBodyHandler = e => {\n      this.axisList.push(e.body);\n    };\n    this.removeBodyHandler = e => {\n      // Remove from list\n      const idx = this.axisList.indexOf(e.body);\n      if (idx !== -1) {\n        this.axisList.splice(idx, 1);\n      }\n    };\n  }\n\n  /**\n   * Change the world\n   * @param world\n   */\n  setWorld(world) {\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    appendArray(this.axisList, world.bodies);\n\n    // Remove old handlers, if any\n    world.off('addBody', this.addBodyHandler).off('removeBody', this.removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.on('addBody', this.addBodyHandler).on('removeBody', this.removeBodyHandler);\n    this.world = world;\n  }\n  sortList() {\n    const bodies = this.axisList;\n    const axisIndex = this.axisIndex;\n\n    // Sort the lists\n    sortAxisList(bodies, axisIndex);\n  }\n\n  /**\n   * Get the colliding pairs\n   */\n  getCollisionPairs(_world) {\n    const bodies = this.axisList;\n    const result = this.result;\n    const axisIndex = this.axisIndex;\n    result.length = 0;\n\n    // Update all AABBs if needed\n    let l = bodies.length;\n    while (l--) {\n      const b = bodies[l];\n      if (b.aabbNeedsUpdate) {\n        b.updateAABB();\n      }\n    }\n\n    // Sort the lists\n    this.sortList();\n\n    // Look through the X list\n    for (let i = 0, N = bodies.length | 0; i !== N; i++) {\n      const bi = bodies[i];\n      for (let j = i + 1; j < N; j++) {\n        const bj = bodies[j];\n\n        // Bounds overlap?\n        const overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];\n        if (!overlaps) {\n          break;\n        }\n        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {\n          result.push(bi, bj);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns all the bodies within an AABB.\n   * @param world\n   * @param aabb\n   * @param result An array to store resulting bodies in.\n   * @return\n   * @todo since the list is sorted, optimization can be done\n   */\n  aabbQuery(world, aabb, result) {\n    if (result === void 0) {\n      result = [];\n    }\n    this.sortList();\n    const axisList = this.axisList;\n    for (let i = 0; i < axisList.length; i++) {\n      const b = axisList[i];\n      if (b.aabbNeedsUpdate) {\n        b.updateAABB();\n      }\n      if (b.aabb.overlaps(aabb)) {\n        result.push(b);\n      }\n    }\n    return result;\n  }\n}\nfunction sortAxisList(a, axisIndex) {\n  axisIndex = axisIndex | 0;\n  for (let i = 1, l = a.length; i < l; i++) {\n    const v = a[i];\n    let j;\n    for (j = i - 1; j >= 0; j--) {\n      if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {\n        break;\n      }\n      a[j + 1] = a[j];\n    }\n    a[j + 1] = v;\n  }\n  return a;\n}\n\n/**\n * Base constraint class.\n */\nclass Constraint {\n  static OTHER = -1;\n  static DISTANCE = 1;\n  static GEAR = 2;\n  static LOCK = 3;\n  static PRISMATIC = 4;\n  static REVOLUTE = 5;\n\n  /**\n   * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.\n   */\n\n  /**\n   * Equations to be solved in this constraint\n   */\n\n  /**\n   * First body participating in the constraint.\n   */\n\n  /**\n   * Second body participating in the constraint.\n   */\n\n  /**\n   * Set to true if you want the connected bodies to collide.\n   * @default true\n   */\n\n  constructor(bodyA, bodyB, type, options) {\n    if (type === void 0) {\n      type = Constraint.OTHER;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    this.type = type;\n    this.equations = [];\n    this.bodyA = bodyA;\n    this.bodyB = bodyB;\n    this.collideConnected = options.collideConnected ?? true;\n\n    // Wake up bodies when connected\n    if (options.wakeUpBodies !== false) {\n      if (bodyA) {\n        bodyA.wakeUp();\n      }\n      if (bodyB) {\n        bodyB.wakeUp();\n      }\n    }\n  }\n\n  /**\n   * Updates the internal constraint parameters before solve.\n   */\n  update() {\n    throw new Error('method update() not implemented in this Constraint subclass!');\n  }\n\n  /**\n   * Set stiffness for this constraint.\n   * @param stiffness\n   */\n  setStiffness(stiffness) {\n    const eqs = this.equations;\n    for (let i = 0; i !== eqs.length; i++) {\n      const eq = eqs[i];\n      eq.stiffness = stiffness;\n      eq.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Set relaxation for this constraint.\n   * @param relaxation\n   */\n  setRelaxation(relaxation) {\n    const eqs = this.equations;\n    for (let i = 0; i !== eqs.length; i++) {\n      const eq = eqs[i];\n      eq.relaxation = relaxation;\n      eq.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Set max bias for this constraint.\n   * @param maxBias\n   */\n  setMaxBias(maxBias) {\n    const eqs = this.equations;\n    for (let i = 0; i !== eqs.length; i++) {\n      const eq = eqs[i];\n      eq.maxBias = maxBias;\n    }\n  }\n}\n\n/**\n * Constraint that tries to keep the distance between two bodies constant.\n *\n * @example\n *     // If distance is not given as an option, then the current distance between the bodies is used.\n *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     var constraint = new DistanceConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     // Manually set the distance and anchors\n *     var constraint = new DistanceConstraint(bodyA, bodyB, {\n *         distance: 1,          // Distance to keep between the points\n *         localAnchorA: [1, 0], // Point on bodyA\n *         localAnchorB: [-1, 0] // Point on bodyB\n *     });\n *     world.addConstraint(constraint);\n */\nclass DistanceConstraint extends Constraint {\n  /**\n   * The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].\n   */\n\n  /**\n   * The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].\n   */\n\n  /**\n   * The distance to keep between the anchor points. Defaults to the current distance between the bodies.\n   */\n\n  /**\n   * Maximum force to apply.\n   */\n\n  /**\n   * If the upper limit is enabled or not.\n   */\n\n  /**\n   * The upper constraint limit.\n   */\n\n  /**\n   * If the lower limit is enabled or not.\n   */\n\n  /**\n   * The lower constraint limit.\n   */\n\n  /**\n   * Current constraint position. This is equal to the current distance between the world anchor points.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, Constraint.DISTANCE, options);\n    this.localAnchorA = options.localAnchorA ? clone(options.localAnchorA) : create();\n    this.localAnchorB = options.localAnchorB ? clone(options.localAnchorB) : create();\n    const localAnchorA = this.localAnchorA;\n    const localAnchorB = this.localAnchorB;\n    this.upperLimit = options.upperLimit ?? 1;\n    this.upperLimitEnabled = options.upperLimit !== undefined;\n    this.lowerLimit = options.lowerLimit ?? 0;\n    this.lowerLimitEnabled = options.lowerLimit !== undefined;\n    if (typeof options.distance === 'number') {\n      this.distance = options.distance;\n    } else {\n      // Use the current world distance between the world anchor points.\n      const worldAnchorA = create();\n      const worldAnchorB = create();\n      const r = create();\n\n      // Transform local anchors to world\n      rotate(worldAnchorA, localAnchorA, bodyA.angle);\n      rotate(worldAnchorB, localAnchorB, bodyB.angle);\n      add(r, bodyB.position, worldAnchorB);\n      subtract(r, r, worldAnchorA);\n      subtract(r, r, bodyA.position);\n      this.distance = length(r);\n    }\n    let maxForce;\n    if (typeof options.maxForce === 'undefined') {\n      maxForce = Number.MAX_VALUE;\n    } else {\n      maxForce = options.maxForce;\n    }\n    const normal = new Equation(bodyA, bodyB, -maxForce, maxForce); // Just in the normal direction\n    this.equations = [normal];\n    this.maxForce = maxForce;\n\n    // g = (xi - xj).dot(n)\n    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'\n\n    // ...and if we were to include offset points:\n    // g =\n    //      (xj + rj - xi - ri).dot(n) - distance\n    //\n    // dg/dt =\n    //      (vj + wj x rj - vi - wi x ri).dot(n) =\n    //      { term 2 is near zero } =\n    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =\n    //      G * W\n    //\n    // => G = [-n -rixn n rjxn]\n\n    const r = create();\n    const ri = create(); // worldAnchorA\n    const rj = create(); // worldAnchorB\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const that = this;\n    normal.computeGq = function () {\n      const bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        xi = bodyA.position,\n        xj = bodyB.position;\n\n      // Transform local anchors to world\n      rotate(ri, localAnchorA, bodyA.angle);\n      rotate(rj, localAnchorB, bodyB.angle);\n      add(r, xj, rj);\n      subtract(r, r, ri);\n      subtract(r, r, xi);\n      return length(r) - that.distance;\n    };\n\n    // Make the contact constraint bilateral\n    this.setMaxForce(maxForce);\n    this.position = 0;\n  }\n\n  /**\n   * Set the max force to be used\n   * @param maxForce\n   */\n  setMaxForce(maxForce) {\n    const normal = this.equations[0];\n    normal.minForce = -maxForce;\n    normal.maxForce = maxForce;\n  }\n\n  /**\n   * Get the max force\n   */\n  getMaxForce() {\n    const normal = this.equations[0];\n    return normal.maxForce;\n  }\n\n  /**\n   * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n   */\n  update() {\n    const normal = this.equations[0],\n      bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      xi = bodyA.position,\n      xj = bodyB.position,\n      normalEquation = this.equations[0],\n      G = normal.G;\n\n    // Transform local anchors to world\n    rotate(ri, this.localAnchorA, bodyA.angle);\n    rotate(rj, this.localAnchorB, bodyB.angle);\n\n    // Get world anchor points and normal\n    add(n, xj, rj);\n    subtract(n, n, ri);\n    subtract(n, n, xi);\n    this.position = length(n);\n    let violating = false;\n    if (this.upperLimitEnabled) {\n      if (this.position > this.upperLimit) {\n        normalEquation.maxForce = 0;\n        normalEquation.minForce = -this.maxForce;\n        this.distance = this.upperLimit;\n        violating = true;\n      }\n    }\n    if (this.lowerLimitEnabled) {\n      if (this.position < this.lowerLimit) {\n        normalEquation.maxForce = this.maxForce;\n        normalEquation.minForce = 0;\n        this.distance = this.lowerLimit;\n        violating = true;\n      }\n    }\n    if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {\n      // No constraint needed.\n      normalEquation.enabled = false;\n      return;\n    }\n    normalEquation.enabled = true;\n    normalize(n, n);\n\n    // Caluclate cross products\n    const rixn = crossLength(ri, n),\n      rjxn = crossLength(rj, n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n  }\n}\nconst n = create();\nconst ri = create(); // worldAnchorA\nconst rj = create(); // worldAnchorB\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n */\nclass AngleLockEquation extends Equation {\n  /**\n   * The gear ratio.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n    this.ratio = options.ratio ?? 1;\n    this.setRatio(this.ratio);\n  }\n  setRatio(ratio) {\n    const G = this.G;\n    G[2] = ratio;\n    G[5] = -1;\n    this.ratio = ratio;\n  }\n  setMaxTorque(torque) {\n    this.maxForce = torque;\n    this.minForce = -torque;\n  }\n  computeGq() {\n    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;\n  }\n}\n\n/**\n * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB, {\n *         ratio: 2,\n *         maxTorque: 1000\n *     });\n *     world.addConstraint(constraint);\n */\nclass GearConstraint extends Constraint {\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, Constraint.GEAR, options);\n\n    /**\n     * The gear ratio.\n     */\n    this.ratio = options.ratio ?? 1;\n\n    /**\n     * The relative angle\n     */\n    this.angle = options.angle ?? bodyB.angle - this.ratio * bodyA.angle;\n\n    // Send same parameters to the equation\n    const angleLockOptions = shallowClone(options);\n    angleLockOptions.angle = this.angle;\n    angleLockOptions.ratio = this.ratio;\n    this.equations = [new AngleLockEquation(bodyA, bodyB, angleLockOptions)];\n\n    // Set max torque\n    if (options.maxTorque !== undefined) {\n      this.setMaxTorque(options.maxTorque);\n    }\n  }\n\n  /**\n   * Set the max torque for the constraint.\n   * @param torque\n   */\n  setMaxTorque(torque) {\n    this.equations[0].setMaxTorque(torque);\n  }\n\n  /**\n   * Get the max torque for the constraint.\n   * @returns\n   */\n  getMaxTorque() {\n    return this.equations[0].maxForce;\n  }\n  update() {\n    const eq = this.equations[0];\n    const ratio = this.ratio;\n    if (eq.ratio !== ratio) {\n      eq.setRatio(ratio);\n    }\n    eq.angle = this.angle;\n  }\n}\n\n/**\n * Locks the relative position and rotation between two bodies.\n *\n * @example\n *     // Locks the relative position and rotation between bodyA and bodyB\n *     var constraint = new LockConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n */\nclass LockConstraint extends Constraint {\n  /**\n   * The offset of bodyB in bodyA's frame.\n   */\n\n  /**\n   * The offset angle of bodyB in bodyA's frame.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, Constraint.LOCK, options);\n    const maxForce = typeof options.maxForce === 'undefined' ? Number.MAX_VALUE : options.maxForce;\n\n    // Use 3 equations:\n    // gx =   (xj - xi - l) * xhat = 0\n    // gy =   (xj - xi - l) * yhat = 0\n    // gr =   (xi - xj + r) * that = 0\n    //\n    // ...where:\n    //   l is the localOffsetB vector rotated to world in bodyA frame\n    //   r is the same vector but reversed and rotated from bodyB frame\n    //   xhat, yhat are world axis vectors\n    //   that is the tangent of r\n    //\n    // For the first two constraints, we get\n    // G*W = (vj - vi - ldot  ) * xhat\n    //     = (vj - vi - wi x l) * xhat\n    //\n    // Since (wi x l) * xhat = (l x xhat) * wi, we get\n    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]\n    //\n    // The last constraint gives\n    // GW = (vi - vj + wj x r) * that\n    //    = [  that   0  -that  (r x t) ]\n\n    const x = new Equation(bodyA, bodyB, -maxForce, maxForce),\n      y = new Equation(bodyA, bodyB, -maxForce, maxForce),\n      rot = new Equation(bodyA, bodyB, -maxForce, maxForce);\n    const l = create(),\n      g = create(),\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      that = this;\n    x.computeGq = function () {\n      rotate(l, that.localOffsetB, bodyA.angle);\n      subtract(g, bodyB.position, bodyA.position);\n      subtract(g, g, l);\n      return g[0];\n    };\n    y.computeGq = function () {\n      rotate(l, that.localOffsetB, bodyA.angle);\n      subtract(g, bodyB.position, bodyA.position);\n      subtract(g, g, l);\n      return g[1];\n    };\n    const r = create(),\n      t = create();\n    rot.computeGq = function () {\n      rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);\n      scale(r, r, -1);\n      subtract(g, bodyA.position, bodyB.position);\n      add(g, g, r);\n      rotate(t, r, -Math.PI / 2);\n      normalize(t, t);\n      return dot(g, t);\n    };\n    this.localOffsetB = create();\n    if (options.localOffsetB) {\n      copy(this.localOffsetB, options.localOffsetB);\n    } else {\n      // Construct from current positions\n      subtract(this.localOffsetB, bodyB.position, bodyA.position);\n      rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);\n    }\n    this.localAngleB = 0;\n    if (typeof options.localAngleB === 'number') {\n      this.localAngleB = options.localAngleB;\n    } else {\n      // Construct\n      this.localAngleB = bodyB.angle - bodyA.angle;\n    }\n    this.equations.push(x, y, rot);\n    this.setMaxForce(maxForce);\n  }\n\n  /**\n   * Set the maximum force to be applied.\n   * @param force\n   */\n  setMaxForce(force) {\n    const eqs = this.equations;\n    for (let i = 0; i < this.equations.length; i++) {\n      eqs[i].maxForce = force;\n      eqs[i].minForce = -force;\n    }\n  }\n\n  /**\n   * Get the max force.\n   */\n  getMaxForce() {\n    return this.equations[0].maxForce;\n  }\n  update() {\n    const x = this.equations[0],\n      y = this.equations[1],\n      rot = this.equations[2],\n      bodyA = this.bodyA,\n      bodyB = this.bodyB;\n    rotate(l, this.localOffsetB, bodyA.angle);\n    rotate(r$1, this.localOffsetB, bodyB.angle - this.localAngleB);\n    scale(r$1, r$1, -1);\n    rotate(t, r$1, Math.PI / 2);\n    normalize(t, t);\n    x.G[0] = -1;\n    x.G[1] = 0;\n    x.G[2] = -crossLength(l, xAxis$2);\n    x.G[3] = 1;\n    y.G[0] = 0;\n    y.G[1] = -1;\n    y.G[2] = -crossLength(l, yAxis$2);\n    y.G[4] = 1;\n    rot.G[0] = -t[0];\n    rot.G[1] = -t[1];\n    rot.G[3] = t[0];\n    rot.G[4] = t[1];\n    rot.G[5] = crossLength(r$1, t);\n  }\n}\nconst l = create();\nconst r$1 = create();\nconst t = create();\nconst xAxis$2 = fromValues(1, 0);\nconst yAxis$2 = fromValues(0, 1);\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n */\nclass RotationalLockEquation extends Equation {\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n    const G = this.G;\n    G[2] = 1;\n    G[5] = -1;\n  }\n  computeGq() {\n    rotate(worldVectorA, xAxis$1, this.bodyA.angle + this.angle);\n    rotate(worldVectorB, yAxis$1, this.bodyB.angle);\n    return dot(worldVectorA, worldVectorB);\n  }\n}\nconst worldVectorA = create();\nconst worldVectorB = create();\nconst xAxis$1 = fromValues(1, 0);\nconst yAxis$1 = fromValues(0, 1);\n\n/**\n * Constraint that only allows bodies to move along a line, relative to each other.\n *\n * Also called \"slider constraint\".\n *\n * @see http://www.iforce2d.net/b2dtut/joints-prismatic\n *\n * @todo Ability to create using only a point and a worldAxis\n *\n * @example\n *     var constraint = new PrismaticConstraint(bodyA, bodyB, {\n *         localAxisA: [0, 1]\n *     });\n *     world.addConstraint(constraint);\n */\nclass PrismaticConstraint extends Constraint {\n  /**\n   * The position of anchor A relative to anchor B, along the constraint axis.\n   */\n\n  /**\n   * Set to true to enable lower limit.\n   */\n\n  /**\n   * Set to true to enable upper limit.\n   */\n\n  /**\n   * Lower constraint limit. The constraint position is forced to be larger than this value.\n   */\n\n  /**\n   * Upper constraint limit. The constraint position is forced to be smaller than this value.\n   */\n\n  /**\n   * Equation used for the motor.\n   */\n\n  /**\n   * The current motor state. Enable or disable the motor using .enableMotor\n   */\n\n  /**\n   * Set the target speed for the motor.\n   */\n\n  /**\n   * Max force for the motor\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, Constraint.PRISMATIC, options);\n\n    // Get anchors\n    const localAnchorA = create();\n    const localAxisA = fromValues(1, 0);\n    const localAnchorB = create();\n    if (options.localAnchorA) {\n      copy(localAnchorA, options.localAnchorA);\n    }\n    if (options.localAxisA) {\n      copy(localAxisA, options.localAxisA);\n    }\n    if (options.localAnchorB) {\n      copy(localAnchorB, options.localAnchorB);\n    }\n    this.localAnchorA = localAnchorA;\n    this.localAnchorB = localAnchorB;\n    this.localAxisA = localAxisA;\n\n    /*\n    The constraint violation for the common axis point is\n     g = ( xj + rj - xi - ri ) * t   :=  gg*t\n    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.\n     gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )\n    Note the use of the chain rule. Now we identify the jacobian\n     G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]\n    The rotational part is just a rotation lock.\n    */\n\n    const maxForce = this.maxForce = options.maxForce ?? Number.MAX_VALUE;\n\n    // Translational part\n    const trans = new Equation(bodyA, bodyB, -maxForce, maxForce);\n    const ri = create(),\n      rj = create(),\n      gg = create(),\n      t = create();\n    trans.computeGq = function () {\n      // g = ( xj + rj - xi - ri ) * t\n      return dot(gg, t);\n    };\n\n    // @ts-expect-error untyped\n    trans.updateJacobian = function () {\n      const G = this.G,\n        xi = bodyA.position,\n        xj = bodyB.position;\n      rotate(ri, localAnchorA, bodyA.angle);\n      rotate(rj, localAnchorB, bodyB.angle);\n      add(gg, xj, rj);\n      subtract(gg, gg, xi);\n      subtract(gg, gg, ri);\n      rotate(t, localAxisA, bodyA.angle + Math.PI / 2);\n      G[0] = -t[0];\n      G[1] = -t[1];\n      G[2] = -crossLength(ri, t) + crossLength(t, gg);\n      G[3] = t[0];\n      G[4] = t[1];\n      G[5] = crossLength(rj, t);\n    };\n    this.equations.push(trans);\n\n    // Rotational part\n    if (!options.disableRotationalLock) {\n      const rot = new RotationalLockEquation(bodyA, bodyB);\n      this.equations.push(rot);\n    }\n    this.position = 0;\n    this.lowerLimitEnabled = options.lowerLimit !== undefined;\n    this.upperLimitEnabled = options.upperLimit !== undefined;\n    this.lowerLimit = options.lowerLimit ?? 0;\n    this.upperLimit = options.upperLimit ?? 1;\n\n    // Equations used for limits\n    this.upperLimitEquation = new ContactEquation(bodyA, bodyB);\n    this.lowerLimitEquation = new ContactEquation(bodyA, bodyB);\n\n    // Set max/min forces\n    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;\n    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;\n    this.motorEquation = new Equation(bodyA, bodyB);\n    this.motorEnabled = false;\n    this.motorSpeed = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const that = this;\n    const motorEquation = this.motorEquation;\n    motorEquation.computeGq = function () {\n      return 0;\n    };\n    motorEquation.computeGW = function () {\n      const G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity,\n        wj = bj.angularVelocity;\n      return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;\n    };\n  }\n\n  /**\n   * Enable the motor\n   */\n  enableMotor() {\n    if (this.motorEnabled) {\n      return;\n    }\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n  }\n\n  /**\n   * Disable the rotational motor\n   */\n  disableMotor() {\n    if (!this.motorEnabled) {\n      return;\n    }\n    const i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i, 1);\n    this.motorEnabled = false;\n  }\n\n  /**\n   * Set the constraint limits.\n   * @param lower lower limit\n   * @param upper upper limit\n   */\n  setLimits(lower, upper) {\n    if (typeof lower === 'number') {\n      this.lowerLimit = lower;\n      this.lowerLimitEnabled = true;\n    } else {\n      this.lowerLimit = lower;\n      this.lowerLimitEnabled = false;\n    }\n    if (typeof upper === 'number') {\n      this.upperLimit = upper;\n      this.upperLimitEnabled = true;\n    } else {\n      this.upperLimit = upper;\n      this.upperLimitEnabled = false;\n    }\n  }\n\n  /**\n   * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n   */\n  update() {\n    const eqs = this.equations,\n      trans = eqs[0],\n      upperLimit = this.upperLimit,\n      lowerLimit = this.lowerLimit,\n      upperLimitEquation = this.upperLimitEquation,\n      lowerLimitEquation = this.lowerLimitEquation,\n      bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      localAxisA = this.localAxisA,\n      localAnchorA = this.localAnchorA,\n      localAnchorB = this.localAnchorB;\n\n    // @ts-expect-error untyped method set in constructor\n    trans.updateJacobian();\n\n    // Transform local things to world\n    rotate(worldAxisA, localAxisA, bodyA.angle);\n    rotate(orientedAnchorA, localAnchorA, bodyA.angle);\n    add(worldAnchorA, orientedAnchorA, bodyA.position);\n    rotate(orientedAnchorB, localAnchorB, bodyB.angle);\n    add(worldAnchorB, orientedAnchorB, bodyB.position);\n    const relPosition = this.position = dot(worldAnchorB, worldAxisA) - dot(worldAnchorA, worldAxisA);\n\n    // Motor\n    if (this.motorEnabled) {\n      // G = [ a     a x ri   -a   -a x rj ]\n      const G = this.motorEquation.G;\n      G[0] = worldAxisA[0];\n      G[1] = worldAxisA[1];\n      G[2] = crossLength(worldAxisA, orientedAnchorB);\n      G[3] = -worldAxisA[0];\n      G[4] = -worldAxisA[1];\n      G[5] = -crossLength(worldAxisA, orientedAnchorA);\n    }\n\n    /*\n        Limits strategy:\n        Add contact equation, with normal along the constraint axis.\n        min/maxForce is set so the constraint is repulsive in the correct direction.\n        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.\n                 ^\n                |\n    upperLimit x\n                |    ------\n        anchorB x<---|  B |\n                |    |    |\n        ------   |    ------\n        |    |   |\n        |  A |-->x anchorA\n        ------   |\n                x lowerLimit\n                |\n                axis\n    */\n\n    if (this.upperLimitEnabled && relPosition > upperLimit) {\n      // Update contact constraint normal, etc\n      scale(upperLimitEquation.normalA, worldAxisA, -1);\n      subtract(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n      subtract(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n      scale(tmp, worldAxisA, upperLimit);\n      add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);\n      if (eqs.indexOf(upperLimitEquation) === -1) {\n        eqs.push(upperLimitEquation);\n      }\n    } else {\n      const idx = eqs.indexOf(upperLimitEquation);\n      if (idx !== -1) {\n        eqs.splice(idx, 1);\n      }\n    }\n    if (this.lowerLimitEnabled && relPosition < lowerLimit) {\n      // Update contact constraint normal, etc\n      scale(lowerLimitEquation.normalA, worldAxisA, 1);\n      subtract(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n      subtract(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n      scale(tmp, worldAxisA, lowerLimit);\n      subtract(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);\n      if (eqs.indexOf(lowerLimitEquation) === -1) {\n        eqs.push(lowerLimitEquation);\n      }\n    } else {\n      const idx = eqs.indexOf(lowerLimitEquation);\n      if (idx !== -1) {\n        eqs.splice(idx, 1);\n      }\n    }\n  }\n}\nconst worldAxisA = create(),\n  worldAnchorA = create(),\n  worldAnchorB = create(),\n  orientedAnchorA = create(),\n  orientedAnchorB = create(),\n  tmp = create();\n\n/**\n * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).\n */\nclass RotationalVelocityEquation extends Equation {\n  constructor(bodyA, bodyB) {\n    super(bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.relativeVelocity = 1;\n    this.ratio = 1;\n  }\n  computeB(a, b, h) {\n    const G = this.G;\n    G[2] = -1;\n    G[5] = this.ratio;\n    const GiMf = this.computeGiMf();\n    const GW = this.computeGW();\n    const B = -GW * b - h * GiMf;\n    return B;\n  }\n}\n\n/**\n * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n *\n * @example\n *     // This will create a revolute constraint between two bodies with pivot point in between them.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     world.addBody(bodyA);\n *\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     world.addBody(bodyB);\n *\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         worldPivot: [0, 0]\n *     });\n *     world.addConstraint(constraint);\n *\n *     // Using body-local pivot points, the constraint could have been constructed like this:\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         localPivotA: [1, 0],\n *         localPivotB: [-1, 0]\n *     });\n */\nclass RevoluteConstraint extends Constraint {\n  /**\n   * The constraint position.\n   */\n\n  /**\n   * Set to true to enable lower limit\n   */\n\n  /**\n   * Set to true to enable upper limit\n   */\n\n  /**\n   * The lower limit on the constraint angle.\n   */\n\n  /**\n   * The upper limit on the constraint angle.\n   */\n\n  get motorEnabled() {\n    return this.motorEquation.enabled;\n  }\n  set motorEnabled(value) {\n    this.motorEquation.enabled = value;\n  }\n  get motorSpeed() {\n    return this.motorEquation.relativeVelocity;\n  }\n  set motorSpeed(value) {\n    this.motorEquation.relativeVelocity = value;\n  }\n  get motorMaxForce() {\n    return this.motorEquation.maxForce;\n  }\n  set motorMaxForce(value) {\n    const eq = this.motorEquation;\n    eq.maxForce = value;\n    eq.minForce = -value;\n  }\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, Constraint.REVOLUTE, options);\n    const maxForce = this.maxForce = options.maxForce ?? Number.MAX_VALUE;\n    const pivotA = this.pivotA = create();\n    const pivotB = this.pivotB = create();\n    if (options.worldPivot) {\n      // Compute pivotA and pivotB\n      subtract(pivotA, options.worldPivot, bodyA.position);\n      subtract(pivotB, options.worldPivot, bodyB.position);\n      // Rotate to local coordinate system\n      rotate(pivotA, pivotA, -bodyA.angle);\n      rotate(pivotB, pivotB, -bodyB.angle);\n    } else {\n      // Get pivotA and pivotB\n      if (options.localPivotA) {\n        copy(pivotA, options.localPivotA);\n      }\n      if (options.localPivotB) {\n        copy(pivotB, options.localPivotB);\n      }\n    }\n    const motorEquation = this.motorEquation = new RotationalVelocityEquation(bodyA, bodyB);\n    motorEquation.enabled = false;\n    const upperLimitEquation = this.upperLimitEquation = new RotationalLockEquation(bodyA, bodyB);\n    const lowerLimitEquation = this.lowerLimitEquation = new RotationalLockEquation(bodyA, bodyB);\n    upperLimitEquation.minForce = lowerLimitEquation.maxForce = 0;\n\n    // Equations to be fed to the solver\n    const eqs = this.equations = [new Equation(bodyA, bodyB, -maxForce, maxForce), new Equation(bodyA, bodyB, -maxForce, maxForce), motorEquation, upperLimitEquation, lowerLimitEquation];\n    const x = eqs[0];\n    const y = eqs[1];\n    x.computeGq = function () {\n      rotate(worldPivotA, pivotA, bodyA.angle);\n      rotate(worldPivotB, pivotB, bodyB.angle);\n      add(g, bodyB.position, worldPivotB);\n      subtract(g, g, bodyA.position);\n      subtract(g, g, worldPivotA);\n      return dot(g, xAxis);\n    };\n    y.computeGq = function () {\n      rotate(worldPivotA, pivotA, bodyA.angle);\n      rotate(worldPivotB, pivotB, bodyB.angle);\n      add(g, bodyB.position, worldPivotB);\n      subtract(g, g, bodyA.position);\n      subtract(g, g, worldPivotA);\n      return dot(g, yAxis);\n    };\n    y.minForce = x.minForce = -maxForce;\n    y.maxForce = x.maxForce = maxForce;\n\n    // These never change but the angular parts do\n    x.G[0] = -1;\n    x.G[1] = 0;\n    x.G[3] = 1;\n    x.G[4] = 0;\n    y.G[0] = 0;\n    y.G[1] = -1;\n    y.G[3] = 0;\n    y.G[4] = 1;\n    this.angle = 0;\n    this.lowerLimitEnabled = false;\n    this.upperLimitEnabled = false;\n    this.lowerLimit = 0;\n    this.upperLimit = 0;\n  }\n\n  /**\n   * Set the constraint angle limits, and enable them.\n   * @param lower the lower limit\n   * @param upper the upper limit\n   */\n  setLimits(lower, upper) {\n    this.lowerLimit = lower;\n    this.upperLimit = upper;\n    this.lowerLimitEnabled = this.upperLimitEnabled = true;\n  }\n  update() {\n    const bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      pivotA = this.pivotA,\n      pivotB = this.pivotB,\n      eqs = this.equations,\n      x = eqs[0],\n      y = eqs[1],\n      upperLimit = this.upperLimit,\n      lowerLimit = this.lowerLimit,\n      upperLimitEquation = this.upperLimitEquation,\n      lowerLimitEquation = this.lowerLimitEquation;\n    const relAngle = this.angle = bodyB.angle - bodyA.angle;\n    upperLimitEquation.angle = upperLimit;\n    upperLimitEquation.enabled = this.upperLimitEnabled && relAngle > upperLimit;\n    lowerLimitEquation.angle = lowerLimit;\n    lowerLimitEquation.enabled = this.lowerLimitEnabled && relAngle < lowerLimit;\n\n    /*\n     The constraint violation is\n         g = xj + rj - xi - ri\n     ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:\n         gdot = vj + wj x rj - vi - wi x ri\n     We split this into x and y directions. (let x and y be unit vectors along the respective axes)\n         gdot * x = ( vj + wj x rj - vi - wi x ri ) * x\n                = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x\n                = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi\n                = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]\n                = G*W\n     ...and similar for y. We have then identified the jacobian entries for x and y directions:\n         Gx = [ x   (rj x x)   -x   -(ri x x)]\n        Gy = [ y   (rj x y)   -y   -(ri x y)]\n     So for example, in the X direction we would get in 2 dimensions\n         G = [ [1   0   (rj x [1,0])   -1   0   -(ri x [1,0])]\n            [0   1   (rj x [0,1])    0  -1   -(ri x [0,1])]\n    */\n\n    rotate(worldPivotA, pivotA, bodyA.angle);\n    rotate(worldPivotB, pivotB, bodyB.angle);\n\n    // @todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc\n\n    const xG = x.G;\n    xG[2] = -crossLength(worldPivotA, xAxis);\n    xG[5] = crossLength(worldPivotB, xAxis);\n    const yG = y.G;\n    yG[2] = -crossLength(worldPivotA, yAxis);\n    yG[5] = crossLength(worldPivotB, yAxis);\n  }\n\n  /**\n   * Enable the rotational motor\n   * @deprecated Use motorEnabled instead\n   */\n  enableMotor() {\n    console.warn('revolute.enableMotor() is deprecated, do revolute.motorEnabled = true; instead.');\n    this.motorEnabled = true;\n  }\n\n  /**\n   * Disable the rotational motor\n   * @deprecated Use motorEnabled instead\n   */\n  disableMotor() {\n    console.warn('revolute.disableMotor() is deprecated, do revolute.motorEnabled = false; instead.');\n    this.motorEnabled = false;\n  }\n\n  /**\n   * Check if the motor is enabled.\n   * @deprecated Use motorEnabled instead\n   * @returns\n   */\n  motorIsEnabled() {\n    console.warn('revolute.motorIsEnabled() is deprecated, use revolute.motorEnabled instead.');\n    return this.motorEnabled;\n  }\n\n  /**\n   * Set the speed of the rotational constraint motor\n   * @deprecated Use .motorSpeed instead\n   * @param speed\n   */\n  setMotorSpeed(speed) {\n    console.warn('revolute.setMotorSpeed(speed) is deprecated, do revolute.motorSpeed = speed; instead.');\n    this.motorSpeed = speed;\n  }\n\n  /**\n   * Get the speed of the rotational constraint motor\n   * @deprecated Use .motorSpeed instead\n   * @returns\n   */\n  getMotorSpeed() {\n    console.warn('revolute.getMotorSpeed() is deprecated, use revolute.motorSpeed instead.');\n    return this.motorSpeed;\n  }\n}\nconst worldPivotA = create(),\n  worldPivotB = create(),\n  xAxis = fromValues(1, 0),\n  yAxis = fromValues(0, 1),\n  g = create();\n\n/**\n * Defines a physics material.\n *\n * To be used with {@link ContactMaterial}.\n *\n * @example\n *     // Create a wooden box\n *     var woodMaterial = new Material();\n *     var boxShape = new Box({\n *         material: woodMaterial\n *     });\n *     body.addShape(boxShape);\n */\nclass Material {\n  /**\n   * The material identifier. Read only.\n   */\n\n  /**\n   * Id counter for materials\n   */\n  static idCounter = 0;\n  constructor() {\n    this.id = Material.idCounter++;\n  }\n}\n\n/**\n * Defines what happens when two materials meet, such as what friction coefficient to use.\n * You can also set other things such as restitution, surface velocity and constraint parameters.\n *\n * Also see {@link Material}\n *\n * @example\n *     var ice = new Material();\n *     var wood = new Material();\n *     var iceWoodContactMaterial = new ContactMaterial(ice, wood, {\n *         friction: 0.2,\n *         restitution: 0.3\n *     });\n *     world.addContactMaterial(iceWoodContactMaterial);\n */\nclass ContactMaterial {\n  /**\n   * The contact material identifier. Read only.\n   */\n\n  /**\n   * First material participating in the contact material\n   */\n\n  /**\n   * Second material participating in the contact material\n   */\n\n  /**\n   * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.\n   * @default 0.3\n   */\n\n  /**\n   * Restitution, or \"bounciness\" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.\n   * @default 0\n   */\n\n  /**\n   * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force.\n   * Default value is {@link Equation.DEFAULT_STIFFNESS}\n   */\n\n  /**\n   * Relaxation of the resulting ContactEquation that this ContactMaterial will generate.\n   * Default value is {@link Equation.DEFAULT_RELAXATION}\n   */\n\n  /**\n   * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness.\n   * Default value is {@link Equation.DEFAULT_STIFFNESS}\n   */\n\n  /**\n   * Relaxation of the resulting friction force. The default value should be good for most simulations.\n   * Default value is {@link Equation.DEFAULT_RELAXATION}\n   */\n\n  /**\n   * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n   */\n\n  /**\n   * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka \"cure for nervous contacts\".\n   */\n\n  /**\n   * Id counter for created contact materials.\n   */\n  static idCounter = 0;\n  constructor(materialA, materialB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!(materialA instanceof Material) || !(materialB instanceof Material)) {\n      throw new Error('First two arguments must be Material instances.');\n    }\n    this.id = ContactMaterial.idCounter++;\n    this.materialA = materialA;\n    this.materialB = materialB;\n    this.friction = options.friction ?? 0.3;\n    this.restitution = options.restitution ?? 0;\n    this.stiffness = options.stiffness ?? Equation.DEFAULT_STIFFNESS;\n    this.relaxation = options.relaxation ?? Equation.DEFAULT_RELAXATION;\n    this.frictionStiffness = options.frictionStiffness ?? Equation.DEFAULT_STIFFNESS;\n    this.frictionRelaxation = options.frictionRelaxation ?? Equation.DEFAULT_RELAXATION;\n    this.surfaceVelocity = options.surfaceVelocity ?? 0;\n    this.contactSkinSize = 0.005;\n  }\n}\n\n/**\n * Base class for {@link LinearSpring} and {@link RotationalSpring}. Not supposed to be used directly.\n */\nclass Spring {\n  /**\n   * Stiffness of the spring.\n   */\n\n  /**\n   * Damping of the spring.\n   */\n\n  /**\n   * First connected body.\n   */\n\n  /**\n   * Second connected body.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.stiffness = options.stiffness ?? 100;\n    this.damping = options.damping ?? 1;\n    this.bodyA = bodyA;\n    this.bodyB = bodyB;\n  }\n\n  /**\n   * Apply the spring force to the connected bodies. Called automatically by the World.\n   */\n}\n\n/**\n * A spring, connecting two bodies.\n *\n * The Spring explicitly adds force and angularForce to the bodies.\n *\n * @example\n *     var spring = new LinearSpring(bodyA, bodyB, {\n *         stiffness: 100,\n *         damping: 1,\n *         localAnchorA: [0,0], // center of bodyA\n *         localAnchorB: [0,0] // center of bodyB\n *     });\n *     world.addSpring(spring);\n */\nclass LinearSpring extends Spring {\n  /**\n   * Anchor for bodyA in local bodyA coordinates.\n   */\n\n  /**\n   * Anchor for bodyB in local bodyB coordinates.\n   */\n\n  /**\n   * Rest length of the spring. Can be set dynamically.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, options);\n    this.localAnchorA = create();\n    this.localAnchorB = create();\n    if (options.localAnchorA) {\n      copy(this.localAnchorA, options.localAnchorA);\n    }\n    if (options.localAnchorB) {\n      copy(this.localAnchorB, options.localAnchorB);\n    }\n    if (options.worldAnchorA) {\n      this.setWorldAnchorA(options.worldAnchorA);\n    }\n    if (options.worldAnchorB) {\n      this.setWorldAnchorB(options.worldAnchorB);\n    }\n    const worldAnchorA = create();\n    const worldAnchorB = create();\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n    const worldDistance = distance(worldAnchorA, worldAnchorB);\n    this.restLength = options.restLength ?? worldDistance;\n  }\n\n  /**\n   * Set the anchor point on body A, using world coordinates.\n   * @param worldAnchorA\n   */\n  setWorldAnchorA(worldAnchorA) {\n    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);\n  }\n\n  /**\n   * Set the anchor point on body B, using world coordinates.\n   * @param worldAnchorB\n   */\n  setWorldAnchorB(worldAnchorB) {\n    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);\n  }\n\n  /**\n   * Get the anchor point on body A, in world coordinates.\n   * @param result\n   */\n  getWorldAnchorA(result) {\n    this.bodyA.toWorldFrame(result, this.localAnchorA);\n  }\n\n  /**\n   * Set the anchor point on body B, using world coordinates.\n   * @param result\n   */\n  getWorldAnchorB(result) {\n    this.bodyB.toWorldFrame(result, this.localAnchorB);\n  }\n\n  /**\n   * Apply the spring force to the connected bodies\n   */\n  applyForce() {\n    const k = this.stiffness,\n      d = this.damping,\n      l = this.restLength,\n      bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      r = applyForce_r,\n      r_unit = applyForce_r_unit,\n      u = applyForce_u,\n      f = applyForce_f,\n      tmp = applyForce_tmp;\n    const worldAnchorA = applyForce_worldAnchorA,\n      worldAnchorB = applyForce_worldAnchorB,\n      ri = applyForce_ri,\n      rj = applyForce_rj;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    subtract(ri, worldAnchorA, bodyA.position);\n    subtract(rj, worldAnchorB, bodyB.position);\n\n    // Compute distance vector between world anchor points\n    subtract(r, worldAnchorB, worldAnchorA);\n    const rlen = length(r);\n    normalize(r_unit, r);\n\n    // Compute relative velocity of the anchor points, u\n    subtract(u, bodyB.velocity, bodyA.velocity);\n    crossZV(tmp, bodyB.angularVelocity, rj);\n    add(u, u, tmp);\n    crossZV(tmp, bodyA.angularVelocity, ri);\n    subtract(u, u, tmp);\n\n    // F = - k * ( x - L ) - D * ( u )\n    scale(f, r_unit, -k * (rlen - l) - d * dot(u, r_unit));\n\n    // Add forces to bodies\n    subtract(bodyA.force, bodyA.force, f);\n    add(bodyB.force, bodyB.force, f);\n\n    // Angular force\n    const ri_x_f = crossLength(ri, f);\n    const rj_x_f = crossLength(rj, f);\n    bodyA.angularForce -= ri_x_f;\n    bodyB.angularForce += rj_x_f;\n  }\n}\nconst applyForce_r = create();\nconst applyForce_r_unit = create();\nconst applyForce_u = create();\nconst applyForce_f = create();\nconst applyForce_worldAnchorA = create();\nconst applyForce_worldAnchorB = create();\nconst applyForce_ri = create();\nconst applyForce_rj = create();\nconst applyForce_tmp = create();\n\n/**\n * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.\n *\n * The spring can be combined with a {@link RevoluteConstraint} to make, for example, a mouse trap.\n *\n * @example\n *     var spring = new RotationalSpring(bodyA, bodyB, {\n *         stiffness: 100,\n *         damping: 1\n *     });\n *     world.addSpring(spring);\n */\nclass RotationalSpring extends Spring {\n  /**\n   * Rest angle of the spring.\n   */\n\n  constructor(bodyA, bodyB, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(bodyA, bodyB, options);\n    this.restAngle = options.restAngle ?? bodyB.angle - bodyA.angle;\n  }\n\n  /**\n   * Apply the spring force to the connected bodies.\n   */\n  applyForce() {\n    const k = this.stiffness,\n      d = this.damping,\n      l = this.restAngle,\n      bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      x = bodyB.angle - bodyA.angle,\n      u = bodyB.angularVelocity - bodyA.angularVelocity;\n    const torque = -k * (x - l) - d * u;\n    bodyA.angularForce -= torque;\n    bodyB.angularForce += torque;\n  }\n}\n\n/**\n * WheelConstraint\n */\nclass WheelConstraint extends Constraint {\n  constructor(vehicle, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(vehicle.chassisBody, vehicle.groundBody);\n    this.vehicle = vehicle;\n    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n    this.steerValue = 0;\n    this.engineForce = 0;\n    this.setSideFriction(options.sideFriction ?? 5);\n    this.localForwardVector = fromValues(0, 1);\n    if (options.localForwardVector) {\n      copy(this.localForwardVector, options.localForwardVector);\n    }\n    this.localPosition = create();\n    if (options.localPosition) {\n      copy(this.localPosition, options.localPosition);\n    }\n    this.equations.push(this.forwardEquation, this.sideEquation);\n    this.setBrakeForce(0);\n  }\n  setBrakeForce(force) {\n    this.forwardEquation.setSlipForce(force);\n  }\n  setSideFriction(force) {\n    this.sideEquation.setSlipForce(force);\n  }\n  getSpeed() {\n    const body = this.vehicle.chassisBody;\n    body.vectorToWorldFrame(relativePoint, this.localForwardVector);\n    body.getVelocityAtPoint(worldVelocity, relativePoint);\n    return dot(worldVelocity, relativePoint);\n  }\n  update() {\n    const body = this.vehicle.chassisBody;\n    const forwardEquation = this.forwardEquation;\n    const sideEquation = this.sideEquation;\n    const steerValue = this.steerValue;\n\n    // Directional\n    body.vectorToWorldFrame(forwardEquation.t, this.localForwardVector);\n    rotate(sideEquation.t, this.localForwardVector, Math.PI / 2);\n    body.vectorToWorldFrame(sideEquation.t, sideEquation.t);\n    rotate(forwardEquation.t, forwardEquation.t, steerValue);\n    rotate(sideEquation.t, sideEquation.t, steerValue);\n\n    // Attachment point\n    body.toWorldFrame(forwardEquation.contactPointB, this.localPosition);\n    copy(sideEquation.contactPointB, forwardEquation.contactPointB);\n    body.vectorToWorldFrame(forwardEquation.contactPointA, this.localPosition);\n    copy(sideEquation.contactPointA, forwardEquation.contactPointA);\n\n    // Add engine force\n    normalize(tmpVec, forwardEquation.t);\n    scale(tmpVec, tmpVec, this.engineForce);\n    this.vehicle.chassisBody.applyForce(tmpVec, forwardEquation.contactPointA);\n  }\n}\n\n/**\n * TopDownVehicle\n *\n * @deprecated This class will be moved out of the core library in future versions.\n *\n * @example\n *\n *     // Create a dynamic body for the chassis\n *     var chassisBody = new Body({\n *         mass: 1\n *     });\n *     var boxShape = new Box({ width: 0.5, height: 1 });\n *     chassisBody.addShape(boxShape);\n *     world.addBody(chassisBody);\n *\n *     // Create the vehicle\n *     var vehicle = new TopDownVehicle(chassisBody);\n *\n *     // Add one front wheel and one back wheel - we don't actually need four :)\n *     var frontWheel = vehicle.addWheel({\n *         localPosition: [0, 0.5] // front\n *     });\n *     frontWheel.setSideFriction(4);\n *\n *     // Back wheel\n *     var backWheel = vehicle.addWheel({\n *         localPosition: [0, -0.5] // back\n *     });\n *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift\n *     vehicle.addToWorld(world);\n *\n *     // Steer value zero means straight forward. Positive is left and negative right.\n *     frontWheel.steerValue = Math.PI / 16;\n *\n *     // Engine force forward\n *     backWheel.engineForce = 10;\n *     backWheel.setBrakeForce(0);\n */\nclass TopDownVehicle {\n  constructor(chassisBody) {\n    this.chassisBody = chassisBody;\n    this.wheels = [];\n\n    // A dummy body to constrain the chassis to\n    this.groundBody = new Body({\n      mass: 0\n    });\n    this.world = null;\n  }\n  addToWorld(world) {\n    this.world = world;\n    world.addBody(this.groundBody);\n    for (let i = 0; i < this.wheels.length; i++) {\n      const wheel = this.wheels[i];\n      world.addConstraint(wheel);\n    }\n  }\n  removeFromWorld() {\n    if (this.world === null) {\n      return;\n    }\n    this.world.removeBody(this.groundBody);\n    for (let i = 0; i < this.wheels.length; i++) {\n      const wheel = this.wheels[i];\n      this.world.removeConstraint(wheel);\n    }\n    this.world = null;\n  }\n  addWheel(wheelOptions) {\n    const wheel = new WheelConstraint(this, wheelOptions);\n    this.wheels.push(wheel);\n    return wheel;\n  }\n}\nconst worldVelocity = create();\nconst relativePoint = create();\nconst tmpVec = create();\n\n/**\n * Options for creating a {@link Capsule}\n */\n\n/**\n * Capsule shape.\n *\n * @example\n *     var body = new Body({ mass: 1 });\n *     var capsuleShape = new Capsule({\n *         length: 1,\n *         radius: 2\n *     });\n *     body.addShape(capsuleShape);\n */\nclass Capsule extends Shape {\n  /**\n   * The distance between the end points, extends along the X axis.\n   */\n\n  /**\n   * Radius of the capsule.\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const params = {\n      length: 1,\n      radius: 1,\n      ...options,\n      type: Shape.CAPSULE\n    };\n    super(params);\n    this.length = params.length;\n    this.radius = params.radius;\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n\n  /**\n   * Compute the mass moment of inertia of the Capsule.\n   */\n  computeMomentOfInertia() {\n    // http://www.efunda.com/math/areas/rectangle.cfm\n    function boxI(w, h) {\n      return w * h * (Math.pow(w, 2) + Math.pow(h, 2)) / 12;\n    }\n    function semiA(r) {\n      return Math.PI * Math.pow(r, 2) / 2;\n    }\n    // http://www.efunda.com/math/areas/CircleHalf.cfm\n    function semiI(r) {\n      return (Math.PI / 4 - 8 / (9 * Math.PI)) * Math.pow(r, 4);\n    }\n    function semiC(r) {\n      return 4 * r / (3 * Math.PI);\n    }\n    // https://en.wikipedia.org/wiki/Second_moment_of_area#Parallel_axis_theorem\n    function capsuleA(l, r) {\n      return l * 2 * r + Math.PI * Math.pow(r, 2);\n    }\n    function capsuleI(l, r) {\n      const d = l / 2 + semiC(r);\n      return boxI(l, 2 * r) + 2 * (semiI(r) + semiA(r) * Math.pow(d, 2));\n    }\n    const r = this.radius,\n      l = this.length,\n      area = capsuleA(l, r);\n    return area > 0 ? capsuleI(l, r) / area : 0;\n  }\n  updateArea() {\n    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;\n  }\n  updateBoundingRadius() {\n    this.boundingRadius = this.radius + this.length / 2;\n  }\n  computeAABB(out, position, angle) {\n    const radius = this.radius;\n\n    // Compute center position of one of the the circles, world oriented, but with local offset\n    set(r, this.length / 2, 0);\n    if (angle !== 0) {\n      rotate(r, r, angle);\n    }\n\n    // Get bounds\n    set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));\n    set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));\n\n    // Add offset\n    add(out.lowerBound, out.lowerBound, position);\n    add(out.upperBound, out.upperBound, position);\n  }\n  raycast(result, ray, position, angle) {\n    const from = ray.from;\n    const to = ray.to;\n    const hitPointWorld = intersectCapsule_hitPointWorld;\n    const normal = intersectCapsule_normal;\n    const l0 = intersectCapsule_l0;\n    const l1 = intersectCapsule_l1;\n\n    // The sides\n    const halfLen = this.length / 2;\n    for (let i = 0; i < 2; i++) {\n      // get start and end of the line\n      const y = this.radius * (i * 2 - 1);\n      set(l0, -halfLen, y);\n      set(l1, halfLen, y);\n      toGlobalFrame(l0, l0, position, angle);\n      toGlobalFrame(l1, l1, position, angle);\n      const delta = getLineSegmentsIntersectionFraction(from, to, l0, l1);\n      if (delta >= 0) {\n        rotate(normal, intersectCapsule_unit_y, angle);\n        scale(normal, normal, i * 2 - 1);\n        ray.reportIntersection(result, delta, normal, -1);\n        if (result.shouldStop(ray)) {\n          return;\n        }\n      }\n    }\n\n    // Circles\n    const diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);\n    for (let i = 0; i < 2; i++) {\n      set(l0, halfLen * (i * 2 - 1), 0);\n      toGlobalFrame(l0, l0, position, angle);\n      const a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n      const b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));\n      const c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);\n      const delta = Math.pow(b, 2) - 4 * a * c;\n      if (delta < 0) {\n        // No intersection\n        continue;\n      } else if (delta === 0) {\n        // single intersection point\n        lerp(hitPointWorld, from, to, delta);\n        if (squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {\n          subtract(normal, hitPointWorld, l0);\n          normalize(normal, normal);\n          ray.reportIntersection(result, delta, normal, -1);\n          if (result.shouldStop(ray)) {\n            return;\n          }\n        }\n      } else {\n        const sqrtDelta = Math.sqrt(delta);\n        const inv2a = 1 / (2 * a);\n        const d1 = (-b - sqrtDelta) * inv2a;\n        const d2 = (-b + sqrtDelta) * inv2a;\n        if (d1 >= 0 && d1 <= 1) {\n          lerp(hitPointWorld, from, to, d1);\n          if (squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {\n            subtract(normal, hitPointWorld, l0);\n            normalize(normal, normal);\n            ray.reportIntersection(result, d1, normal, -1);\n            if (result.shouldStop(ray)) {\n              return;\n            }\n          }\n        }\n        if (d2 >= 0 && d2 <= 1) {\n          lerp(hitPointWorld, from, to, d2);\n          if (squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {\n            subtract(normal, hitPointWorld, l0);\n            normalize(normal, normal);\n            ray.reportIntersection(result, d2, normal, -1);\n            if (result.shouldStop(ray)) {\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n  pointTest(localPoint) {\n    const radius = this.radius;\n    const halfLength = this.length * 0.5;\n    if (Math.abs(localPoint[0]) <= halfLength && Math.abs(localPoint[1]) <= radius) {\n      return true;\n    }\n    if (Math.pow(localPoint[0] - halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {\n      return true;\n    }\n    if (Math.pow(localPoint[0] + halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {\n      return true;\n    }\n    return false;\n  }\n}\nconst r = create();\nconst intersectCapsule_hitPointWorld = create();\nconst intersectCapsule_normal = create();\nconst intersectCapsule_l0 = create();\nconst intersectCapsule_l1 = create();\nconst intersectCapsule_unit_y = fromValues(0, 1);\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance \"elementWidth\".\n *\n * @example\n *     // Generate some height data (y-values).\n *     var heights = [];\n *     for(var i = 0; i < 1000; i++){\n *         var y = 0.5 * Math.cos(0.2 * i);\n *         heights.push(y);\n *     }\n *\n *     // Create the heightfield shape\n *     var shape = new Heightfield({\n *         heights: heights,\n *         elementWidth: 1 // Distance between the data points in X direction\n *     });\n *     var body = new Body();\n *     body.addShape(shape);\n *     world.addBody(body);\n *\n * @todo Should use a scale property with X and Y direction instead of just elementWidth\n */\nclass Heightfield extends Shape {\n  /**\n   * An array of numbers, or height values, that are spread out along the x axis.\n   */\n\n  /**\n   * Max value of the heights\n   */\n\n  /**\n   * Min value of the heights\n   */\n\n  /**\n   * The width of each element\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const params = {\n      elementWidth: 0.1,\n      ...options,\n      type: Shape.HEIGHTFIELD,\n      heights: options.heights ? [...options.heights] : []\n    };\n    super(params);\n    this.heights = params.heights;\n    this.maxValue = params.maxValue;\n    this.minValue = params.minValue;\n    this.elementWidth = params.elementWidth;\n    if (params.maxValue === undefined || params.minValue === undefined) {\n      this.updateMaxMinValues();\n    }\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n  updateMaxMinValues() {\n    const data = this.heights;\n    let maxValue = data[0];\n    let minValue = data[0];\n    for (let i = 0; i !== data.length; i++) {\n      const v = data[i];\n      if (v > maxValue) {\n        maxValue = v;\n      }\n      if (v < minValue) {\n        minValue = v;\n      }\n    }\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n  }\n  computeMomentOfInertia() {\n    return Number.MAX_VALUE;\n  }\n  updateBoundingRadius() {\n    this.boundingRadius = Number.MAX_VALUE;\n  }\n  updateArea() {\n    const data = this.heights;\n    let area = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n      area += (data[i] + data[i + 1]) / 2 * this.elementWidth;\n    }\n    this.area = area;\n  }\n  computeAABB(out, position, angle) {\n    set(points$1[0], 0, this.maxValue);\n    set(points$1[1], this.elementWidth * this.heights.length, this.maxValue);\n    set(points$1[2], this.elementWidth * this.heights.length, this.minValue);\n    set(points$1[3], 0, this.minValue);\n    out.setFromPoints(points$1, position, angle);\n  }\n\n  /**\n   * Get a line segment in the heightfield\n   * @param start Where to store the resulting start point\n   * @param end Where to store the resulting end point\n   * @param i\n   */\n  getLineSegment(start, end, i) {\n    const data = this.heights;\n    const width = this.elementWidth;\n    set(start, i * width, data[i]);\n    set(end, (i + 1) * width, data[i + 1]);\n  }\n  getSegmentIndex(position) {\n    return Math.floor(position[0] / this.elementWidth);\n  }\n  getClampedSegmentIndex(position) {\n    let i = this.getSegmentIndex(position);\n    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp\n    return i;\n  }\n  raycast(result, ray, position, angle) {\n    const from = ray.from;\n    const to = ray.to;\n    const worldNormal = intersectHeightfield_worldNormal;\n    const l0 = intersectHeightfield_l0;\n    const l1 = intersectHeightfield_l1;\n    const localFrom = intersectHeightfield_localFrom;\n    const localTo = intersectHeightfield_localTo;\n\n    // get local ray start and end\n    toLocalFrame(localFrom, from, position, angle);\n    toLocalFrame(localTo, to, position, angle);\n\n    // Get the segment range\n    this.getClampedSegmentIndex(localFrom);\n    this.getClampedSegmentIndex(localTo);\n\n    // The segments\n    for (let i = 0; i < this.heights.length - 1; i++) {\n      this.getLineSegment(l0, l1, i);\n      const t = getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);\n      if (t >= 0) {\n        subtract(worldNormal, l1, l0);\n        rotate(worldNormal, worldNormal, angle + Math.PI / 2);\n        normalize(worldNormal, worldNormal);\n        ray.reportIntersection(result, t, worldNormal, -1);\n        if (result.shouldStop(ray)) {\n          return;\n        }\n      }\n    }\n  }\n}\nconst points$1 = [create(), create(), create(), create()];\nconst intersectHeightfield_worldNormal = create();\nconst intersectHeightfield_l0 = create();\nconst intersectHeightfield_l1 = create();\nconst intersectHeightfield_localFrom = create();\nconst intersectHeightfield_localTo = create();\n\n/**\n * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n *\n * @example\n *     var body = new Body();\n *     var lineShape = new Line({\n *         length: 1\n *     });\n *     body.addShape(lineShape);\n */\nclass Line extends Shape {\n  /**\n   * Length of the line\n   * @default 1\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const params = {\n      length: 1,\n      ...options,\n      type: Shape.LINE\n    };\n    super(params);\n    this.length = params.length;\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n  computeMomentOfInertia() {\n    return Math.pow(this.length, 2) / 12;\n  }\n  updateBoundingRadius() {\n    this.boundingRadius = this.length / 2;\n  }\n  computeAABB(out, position, angle) {\n    const l2 = this.length / 2;\n    set(points[0], -l2, 0);\n    set(points[1], l2, 0);\n    out.setFromPoints(points, position, angle, 0);\n  }\n  raycast(result, ray, position, angle) {\n    const from = ray.from;\n    const to = ray.to;\n    const l0 = raycast_l0;\n    const l1 = raycast_l1;\n\n    // get start and end of the line\n    const halfLen = this.length / 2;\n    set(l0, -halfLen, 0);\n    set(l1, halfLen, 0);\n    toGlobalFrame(l0, l0, position, angle);\n    toGlobalFrame(l1, l1, position, angle);\n    const fraction = getLineSegmentsIntersectionFraction(from, to, l0, l1);\n    if (fraction >= 0) {\n      const normal = raycast_normal;\n      rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from\n      ray.reportIntersection(result, fraction, normal, -1);\n    }\n  }\n}\nconst points = [create(), create()];\nconst raycast_normal = create();\nconst raycast_l0 = create();\nconst raycast_l1 = create();\nconst raycast_unit_y = fromValues(0, 1);\n\nclass Particle extends Shape {\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super({\n      ...options,\n      type: Shape.PARTICLE\n    });\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n  computeMomentOfInertia() {\n    return 0; // Can't rotate a particle\n  }\n\n  updateBoundingRadius() {\n    this.boundingRadius = 0;\n  }\n  computeAABB(out, position) {\n    copy(out.lowerBound, position);\n    copy(out.upperBound, position);\n  }\n}\n\n/**\n * Plane shape class. The plane is facing in the Y direction.\n *\n * @example\n *     var body = new Body();\n *     var shape = new Plane();\n *     body.addShape(shape);\n */\nclass Plane extends Shape {\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super({\n      ...options,\n      type: Shape.PLANE\n    });\n    this.updateBoundingRadius();\n    this.updateArea();\n  }\n  computeMomentOfInertia() {\n    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here\n  }\n\n  updateBoundingRadius() {\n    this.boundingRadius = Number.MAX_VALUE;\n  }\n  updateArea() {\n    this.area = Number.MAX_VALUE;\n  }\n  computeAABB(out, position, angle) {\n    const a = angle % (2 * Math.PI);\n    const set$1 = set;\n    const max = 1e7;\n    const lowerBound = out.lowerBound;\n    const upperBound = out.upperBound;\n\n    // Set max bounds\n    set$1(lowerBound, -max, -max);\n    set$1(upperBound, max, max);\n    if (a === 0) {\n      // y goes from -inf to 0\n      upperBound[1] = position[1];\n    } else if (a === Math.PI / 2) {\n      // x goes from 0 to inf\n      lowerBound[0] = position[0];\n    } else if (a === Math.PI) {\n      // y goes from 0 to inf\n      lowerBound[1] = position[1];\n    } else if (a === 3 * Math.PI / 2) {\n      // x goes from -inf to 0\n      upperBound[0] = position[0];\n    }\n  }\n  raycast(result, ray, position, angle) {\n    const from = ray.from;\n    const to = ray.to;\n    const direction = ray.direction;\n    const planePointToFrom = intersectPlane_planePointToFrom;\n    const normal = intersectPlane_normal;\n    const len = intersectPlane_len;\n\n    // Get plane normal\n    set(normal, 0, 1);\n    rotate(normal, normal, angle);\n    subtract(len, from, position);\n    const planeToFrom = dot(len, normal);\n    subtract(len, to, position);\n    const planeToTo = dot(len, normal);\n    if (planeToFrom * planeToTo > 0) {\n      // \"from\" and \"to\" are on the same side of the plane... bail out\n      return;\n    }\n    if (squaredDistance(from, to) < planeToFrom * planeToFrom) {\n      return;\n    }\n    const n_dot_dir = dot(normal, direction);\n    subtract(planePointToFrom, from, position);\n    const t = -dot(normal, planePointToFrom) / n_dot_dir / ray.length;\n    ray.reportIntersection(result, t, normal, -1);\n  }\n  pointTest(localPoint) {\n    return localPoint[1] <= 0;\n  }\n}\nconst intersectPlane_planePointToFrom = create();\nconst intersectPlane_normal = create();\nconst intersectPlane_len = create();\n\n/**\n * Base class for constraint solvers.\n */\nclass Solver {\n  /**\n   * Gauss-Seidel solver.\n   */\n\n  /**\n   * The type of solver.\n   */\n\n  /**\n   * Current equations in the solver.\n   */\n\n  /**\n   * Function that is used to sort all equations before each solve.\n   */\n\n  constructor(options, type) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.type = type;\n    this.equations = [];\n    this.equationSortFunction = options.equationSortFunction;\n  }\n\n  /**\n   * Method to be implemented in each subclass\n   * @param dt\n   * @param world\n   */\n\n  /**\n   * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.\n   */\n  sortEquations() {\n    if (this.equationSortFunction) {\n      this.equations.sort(this.equationSortFunction);\n    }\n  }\n\n  /**\n   * Add an equation to be solved.\n   * @param eq\n   */\n  addEquation(eq) {\n    if (eq.enabled) {\n      this.equations.push(eq);\n    }\n  }\n\n  /**\n   * Add equations. Same as .addEquation, but this time the argument is an array of Equations\n   * @param eqs\n   */\n  addEquations(eqs) {\n    for (let i = 0, N = eqs.length; i !== N; i++) {\n      const eq = eqs[i];\n      if (eq.enabled) {\n        this.equations.push(eq);\n      }\n    }\n  }\n\n  /**\n   * Removes an equation\n   * @param eq\n   */\n  removeEquation(eq) {\n    const i = this.equations.indexOf(eq);\n    if (i !== -1) {\n      this.equations.splice(i, 1);\n    }\n  }\n\n  /**\n   * Removes all currently added equations\n   */\n  removeAllEquations() {\n    this.equations.length = 0;\n  }\n}\n\n/**\n * Iterative Gauss-Seidel constraint equation solver.\n */\nclass GSSolver extends Solver {\n  type = Solver.GS;\n\n  /**\n   * The max number of iterations to do when solving. More gives better results, but is more expensive.\n   */\n\n  /**\n   * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.\n   * @default 1e-7\n   */\n\n  /**\n   * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.\n   *\n   * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.\n   * @default 0\n   */\n\n  /**\n   * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.\n   */\n\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super(options, Solver.GS);\n    this.iterations = options.iterations ?? 10;\n    this.tolerance = options.tolerance ?? 1e-7;\n    this.frictionIterations = options.frictionIterations ?? 0;\n    this.usedIterations = 0;\n  }\n  solve(h, world) {\n    this.sortEquations();\n    let iter = 0;\n    const maxIter = this.iterations;\n    const maxFrictionIter = this.frictionIterations;\n    const equations = this.equations;\n    const Neq = equations.length;\n    const tolSquared = Math.pow(this.tolerance * Neq, 2);\n    const bodies = world.bodies;\n    const Nbodies = bodies.length;\n    this.usedIterations = 0;\n    if (Neq) {\n      for (let i = 0; i !== Nbodies; i++) {\n        const b = bodies[i];\n\n        // Update solve mass\n        b.updateSolveMassProperties();\n      }\n    }\n    for (let i = 0; i !== Neq; i++) {\n      const c = equations[i];\n      c.lambda = 0;\n      if (c.timeStep !== h || c.needsUpdate) {\n        c.timeStep = h;\n        c.update();\n      }\n      c.B = c.computeB(c.a, c.b, h);\n      c.invC = c.computeInvC(c.epsilon);\n      c.maxForceDt = c.maxForce * h;\n      c.minForceDt = c.minForce * h;\n    }\n    let c, deltalambdaTot, i, j;\n    if (Neq !== 0) {\n      for (i = 0; i !== Nbodies; i++) {\n        const b = bodies[i];\n\n        // Reset vlambda\n        b.resetConstraintVelocity();\n      }\n      if (maxFrictionIter) {\n        // Iterate over contact equations to get normal forces\n        for (iter = 0; iter !== maxFrictionIter; iter++) {\n          // Accumulate the total error for each iteration.\n          deltalambdaTot = 0.0;\n          for (j = 0; j !== Neq; j++) {\n            c = equations[j];\n            const deltalambda = iterateEquation(c);\n            deltalambdaTot += Math.abs(deltalambda);\n          }\n          this.usedIterations++;\n\n          // If the total error is small enough - stop iterate\n          if (deltalambdaTot * deltalambdaTot <= tolSquared) {\n            break;\n          }\n        }\n        updateMultipliers(equations, 1 / h);\n\n        // Set computed friction force\n        for (j = 0; j !== Neq; j++) {\n          const eq = equations[j];\n          if (eq instanceof FrictionEquation) {\n            let f = 0.0;\n            for (let k = 0; k !== eq.contactEquations.length; k++) {\n              f += eq.contactEquations[k].multiplier;\n            }\n            f *= eq.frictionCoefficient / eq.contactEquations.length;\n            eq.maxForce = f;\n            eq.minForce = -f;\n            eq.maxForceDt = f * h;\n            eq.minForceDt = -f * h;\n          }\n        }\n      }\n\n      // Iterate over all equations\n      for (iter = 0; iter !== maxIter; iter++) {\n        // Accumulate the total error for each iteration.\n        deltalambdaTot = 0.0;\n        for (j = 0; j !== Neq; j++) {\n          c = equations[j];\n          const deltalambda = iterateEquation(c);\n          deltalambdaTot += Math.abs(deltalambda);\n        }\n        this.usedIterations++;\n\n        // If the total error is small enough - stop iterate\n        if (deltalambdaTot * deltalambdaTot < tolSquared) {\n          break;\n        }\n      }\n\n      // Add result to velocity\n      for (i = 0; i !== Nbodies; i++) {\n        bodies[i].addConstraintVelocity();\n      }\n      updateMultipliers(equations, 1 / h);\n    }\n  }\n}\n\n// Sets the .multiplier property of each equation\nfunction updateMultipliers(equations, invDt) {\n  let l = equations.length;\n  while (l--) {\n    const eq = equations[l];\n    eq.multiplier = eq.lambda * invDt;\n  }\n}\nfunction iterateEquation(eq) {\n  // Compute iteration\n  const B = eq.B,\n    eps = eq.epsilon,\n    invC = eq.invC,\n    lambdaj = eq.lambda,\n    GWlambda = eq.computeGWlambda(),\n    maxForce_dt = eq.maxForceDt,\n    minForce_dt = eq.minForceDt;\n  let deltalambda = invC * (B - GWlambda - eps * lambdaj);\n\n  // Clamp if we are not within the min/max interval\n  const lambdaj_plus_deltalambda = lambdaj + deltalambda;\n  if (lambdaj_plus_deltalambda < minForce_dt) {\n    deltalambda = minForce_dt - lambdaj;\n  } else if (lambdaj_plus_deltalambda > maxForce_dt) {\n    deltalambda = maxForce_dt - lambdaj;\n  }\n  eq.lambda += deltalambda;\n  eq.addToWlambda(deltalambda);\n  return deltalambda;\n}\n\n/**\n * Overlap data container for the OverlapKeeper\n */\nclass OverlapKeeperRecord {\n  constructor(bodyA, shapeA, bodyB, shapeB) {\n    this.bodyA = bodyA;\n    this.shapeA = shapeA;\n    this.bodyB = bodyB;\n    this.shapeB = shapeB;\n  }\n\n  /**\n   * Set the data for the record\n   * @param bodyA\n   * @param shapeA\n   * @param bodyB\n   * @param shapeB\n   */\n  set(bodyA, shapeA, bodyB, shapeB) {\n    this.bodyA = bodyA;\n    this.shapeA = shapeA;\n    this.bodyB = bodyB;\n    this.shapeB = shapeB;\n  }\n}\n\nclass OverlapKeeperRecordPool extends Pool {\n  create() {\n    return new OverlapKeeperRecord(tmpBody, tmpShape, tmpBody, tmpShape);\n  }\n  destroy(record) {\n    record.bodyA = record.bodyB = tmpBody;\n    record.shapeA = record.shapeB = tmpShape;\n    return this;\n  }\n}\nconst tmpShape = new Circle({\n  radius: 1\n});\nconst tmpBody = new Body();\n\nclass OverlapKeeper {\n  constructor() {\n    this.overlappingShapesLastState = new TupleDictionary();\n    this.overlappingShapesCurrentState = new TupleDictionary();\n    this.recordPool = new OverlapKeeperRecordPool({\n      size: 16\n    });\n    this.tmpDict = new TupleDictionary();\n    this.tmpArray1 = [];\n  }\n\n  /**\n   * Ticks one step forward in time. This will move the current overlap state to the \"old\" overlap state, and create a new one as current.\n   */\n  tick() {\n    const last = this.overlappingShapesLastState;\n    const current = this.overlappingShapesCurrentState;\n\n    // Save old objects into pool\n    let l = last.keys.length;\n    while (l--) {\n      const key = last.keys[l];\n      const lastObject = last.getByKey(key);\n      if (lastObject) {\n        // The record is only used in the \"last\" dict, and will be removed. We might as well pool it.\n        this.recordPool.release(lastObject);\n      }\n    }\n\n    // Transfer from new object to old\n    last.copy(current);\n\n    // Clear current object\n    current.reset();\n  }\n\n  /**\n   * Checks if two bodies are currently overlapping.\n   * @param bodyA\n   * @param bodyB\n   * @return if two bodies are currently overlapping\n   */\n  bodiesAreOverlapping(bodyA, bodyB) {\n    const current = this.overlappingShapesCurrentState;\n    let l = current.keys.length;\n    while (l--) {\n      const key = current.keys[l];\n      const data = current.data[key];\n      if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {\n        return true;\n      }\n    }\n    return false;\n  }\n  setOverlapping(bodyA, shapeA, bodyB, shapeB) {\n    const current = this.overlappingShapesCurrentState;\n\n    // Store current contact state\n    if (!current.get(shapeA.id, shapeB.id)) {\n      const data = this.recordPool.get();\n      data.set(bodyA, shapeA, bodyB, shapeB);\n      current.set(shapeA.id, shapeB.id, data);\n    }\n  }\n  getNewOverlaps(result) {\n    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);\n  }\n  getEndOverlaps(result) {\n    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);\n  }\n  getDiff(dictA, dictB, result) {\n    if (result === void 0) {\n      result = [];\n    }\n    const last = dictA;\n    const current = dictB;\n    result.length = 0;\n    let l = current.keys.length;\n    while (l--) {\n      const key = current.keys[l];\n      const data = current.data[key];\n      if (!data) {\n        throw new Error('Key ' + key + ' had no data!');\n      }\n      const lastData = last.data[key];\n      if (!lastData) {\n        // Not overlapping in last state, but in current.\n        result.push(data);\n      }\n    }\n    return result;\n  }\n  isNewOverlap(shapeA, shapeB) {\n    const idA = shapeA.id | 0,\n      idB = shapeB.id | 0;\n    const last = this.overlappingShapesLastState;\n    const current = this.overlappingShapesCurrentState;\n    // Not in last but in new\n    return !last.get(idA, idB) && !!current.get(idA, idB);\n  }\n  getNewBodyOverlaps(result) {\n    this.tmpArray1.length = 0;\n    const overlaps = this.getNewOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n  }\n  getEndBodyOverlaps(result) {\n    this.tmpArray1.length = 0;\n    const overlaps = this.getEndOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n  }\n  getBodyDiff(overlaps, result) {\n    if (result === void 0) {\n      result = [];\n    }\n    const accumulator = this.tmpDict;\n    let l = overlaps.length;\n    while (l--) {\n      const data = overlaps[l];\n\n      // Since we use body id's for the accumulator, these will be a subset of the original one\n      accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);\n    }\n    l = accumulator.keys.length;\n    while (l--) {\n      const data = accumulator.getByKey(accumulator.keys[l]);\n      if (data) {\n        result.push(data.bodyA, data.bodyB);\n      }\n    }\n    accumulator.reset();\n    return result;\n  }\n}\n\n/**\n * Weighted Quick Union-Find with Path Compression. Based on https://github.com/juzerali/unionfind, but optimized for performance.\n */\nclass UnionFind {\n  id = [];\n  sz = [];\n  constructor(size) {\n    this.size = size;\n    this.count = size;\n    this.resize(size);\n  }\n  resize(size) {\n    this.count = this.size = size;\n    const sz = this.sz;\n    const id = this.id;\n    for (let i = 0; i < size; i++) {\n      id[i] = i;\n      sz[i] = 1;\n    }\n  }\n  find(p) {\n    const id = this.id;\n    while (p !== id[p]) {\n      id[p] = id[id[p]];\n      p = id[p];\n    }\n    return p;\n  }\n\n  /**\n   * Combine elements in groups p and q into a single group. In other words connect the two groups.\n   * @param p\n   * @param q\n   */\n  union(p, q) {\n    const i = this.find(p),\n      j = this.find(q);\n    if (i === j) {\n      return;\n    }\n    const sz = this.sz;\n    const id = this.id;\n    if (sz[i] < sz[j]) {\n      id[i] = j;\n      sz[j] += sz[i];\n    } else {\n      id[j] = i;\n      sz[i] += sz[j];\n    }\n    this.count--;\n    return;\n  }\n}\n\n/**\n * The dynamics world, where all bodies and constraints live.\n *\n * @example\n *     var world = new World({\n *         gravity: [0, -10],\n *         broadphase: new SAPBroadphase()\n *     });\n *     world.addBody(new Body());\n */\nclass World extends EventEmitter {\n  /**\n   * Never deactivate bodies.\n   */\n  static NO_SLEEPING = 1;\n\n  /**\n   * Deactivate individual bodies if they are sleepy.\n   */\n  static BODY_SLEEPING = 2;\n\n  /**\n   * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {@link World.islandSplit} for this to work.\n   */\n  static ISLAND_SLEEPING = 4;\n\n  /**\n   * All springs in the world. To add a spring to the world, use {@link World.addSpring}.\n   */\n  springs = [];\n\n  /**\n   * All bodies in the world. To add a body to the world, use {@link World.addBody}.\n   */\n  bodies = [];\n\n  /**\n   * True if any bodies are not sleeping, false if every body is sleeping.\n   */\n  hasActiveBodies = false;\n\n  /**\n   * The solver used to satisfy constraints and contacts. Default is {@link GSSolver}.\n   */\n\n  /**\n   * The narrowphase to use to generate contacts.\n   */\n  narrowphase = new Narrowphase();\n\n  /**\n   * Gravity in the world. This is applied on all bodies in the beginning of each step().\n   */\n\n  /**\n   * Gravity to use when approximating the friction max force (mu*mass*gravity).\n   */\n\n  /**\n   * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.\n   * @default true\n   */\n  useWorldGravityAsFrictionGravity = true;\n\n  /**\n   * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.\n   * @default true\n   */\n  useFrictionGravityOnZeroGravity = true;\n\n  /**\n   * The broadphase algorithm to use.\n   */\n\n  /**\n   * User-added constraints.\n   */\n  constraints = [];\n\n  /**\n   * Dummy default material in the world, used in .defaultContactMaterial\n   */\n\n  /**\n   * The default contact material to use, if no contact material was set for the colliding materials.\n   */\n\n  /**\n   * For keeping track of what time step size we used last step\n   */\n  lastTimeStep = 1 / 60;\n\n  /**\n   * Enable to automatically apply spring forces each step.\n   * @default true\n   */\n  applySpringForces = true;\n\n  /**\n   * Enable to automatically apply body damping each step.\n   * @default true\n   */\n  applyDamping = true;\n\n  /**\n   * Enable to automatically apply gravity each step.\n   * @default true\n   */\n  applyGravity = true;\n\n  /**\n   * Enable/disable constraint solving in each step.\n   * @default true\n   */\n  solveConstraints = true;\n\n  /**\n   * The ContactMaterials added to the World.\n   */\n  contactMaterials = [];\n\n  /**\n   * World time.\n   */\n  time = 0.0;\n\n  /**\n   * Accumulator for the world\n   */\n  accumulator = 0;\n\n  /**\n   * Is true during step().\n   */\n  stepping = false;\n\n  /**\n   * Whether to enable island splitting.\n   * Island splitting can be an advantage for both precision and performance.\n   * @default false\n   */\n\n  /**\n   * Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n   * @default true\n   * @deprecated Impact event will be removed. Use beginContact instead.\n   */\n  emitImpactEvent = true;\n\n  /**\n   * How to deactivate bodies during simulation. Possible modes are: {@link World,NO_SLEEPING}, {@link World.BODY_SLEEPING} and {@link World.ISLAND_SLEEPING}.\n   * If sleeping is enabled, you might need to {@link Body.wakeUp} the bodies if they fall asleep when they shouldn't.\n   * If you want to enable sleeping in the world, but want to disable it for a particular body, see {@link Body.allowSleep}.\n   * @default World.NO_SLEEPING\n   */\n  sleepMode = World.NO_SLEEPING;\n\n  /**\n   * Overlap keeper for the world\n   */\n  overlapKeeper = new OverlapKeeper();\n\n  /**\n   * Disabled body collision pairs. See {@link World.disableBodyCollision}.\n   */\n  disabledBodyCollisionPairs = [];\n  unionFind = new UnionFind(1);\n\n  /**\n   * Constructor for a p2-es World\n   * @param options options for creating the world\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    super();\n    this.solver = options.solver || new GSSolver();\n    this.gravity = fromValues(0, -9.78);\n    if (options.gravity) {\n      copy(this.gravity, options.gravity);\n    }\n    this.frictionGravity = length(this.gravity) || 10;\n    this.broadphase = options.broadphase || new SAPBroadphase();\n    this.broadphase.setWorld(this);\n    this.defaultMaterial = new Material();\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);\n    this.islandSplit = options.islandSplit ?? true;\n  }\n\n  /**\n   * Add a constraint to the simulation. Note that both bodies connected to the constraint must be added to the world first. Also note that you can't run this method during step.\n   * @param constraint\n   *\n   * @example\n   *     var constraint = new LockConstraint(bodyA, bodyB);\n   *     world.addConstraint(constraint);\n   */\n  addConstraint(constraint) {\n    if (this.stepping) {\n      throw new Error('Constraints cannot be added during step.');\n    }\n    const bodies = this.bodies;\n    if (bodies.indexOf(constraint.bodyA) === -1) {\n      throw new Error('Cannot add Constraint: bodyA is not added to the World.');\n    }\n    if (bodies.indexOf(constraint.bodyB) === -1) {\n      throw new Error('Cannot add Constraint: bodyB is not added to the World.');\n    }\n    this.constraints.push(constraint);\n  }\n\n  /**\n   * Add a ContactMaterial to the simulation.\n   * @param contactMaterial\n   */\n  addContactMaterial(contactMaterial) {\n    this.contactMaterials.push(contactMaterial);\n  }\n\n  /**\n   * Removes a contact material\n   * @param cm\n   */\n  removeContactMaterial(cm) {\n    arrayRemove(this.contactMaterials, cm);\n  }\n\n  /**\n   * Get a contact material given two materials\n   * @param materialA\n   * @param materialB\n   * @todo Use faster hash map to lookup from material id's\n   */\n  getContactMaterial(materialA, materialB) {\n    const cmats = this.contactMaterials;\n    for (let i = 0, N = cmats.length; i !== N; i++) {\n      const cm = cmats[i];\n      if (cm.materialA === materialA && cm.materialB === materialB || cm.materialA === materialB && cm.materialB === materialA) {\n        return cm;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Removes a constraint. Note that you can't run this method during step.\n   * @param constraint\n   */\n  removeConstraint(constraint) {\n    if (this.stepping) {\n      throw new Error('Constraints cannot be removed during step.');\n    }\n    arrayRemove(this.constraints, constraint);\n  }\n\n  /**\n   * Step the physics world forward in time.\n   *\n   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n   *\n   * @param dt The fixed time step size to use.\n   * @param timeSinceLastCalled The time elapsed since the function was last called.\n   * @param maxSubSteps Maximum number of fixed steps to take per function call.\n   *\n   * @example\n   *     // Simple fixed timestepping without interpolation\n   *     var fixedTimeStep = 1 / 60;\n   *     var world = new World();\n   *     var body = new Body({ mass: 1 });\n   *     world.addBody(body);\n   *\n   *     function animate(){\n   *         requestAnimationFrame(animate);\n   *         world.step(fixedTimeStep);\n   *         renderBody(body.position, body.angle);\n   *     }\n   *\n   *     // Start animation loop\n   *     requestAnimationFrame(animate);\n   *\n   * @example\n   *     // Fixed timestepping with interpolation\n   *     var maxSubSteps = 10;\n   *     var lastTimeSeconds;\n   *\n   *     function animate(time){\n   *         requestAnimationFrame(animate);\n   *         var timeSeconds = time / 1000;\n   *\n   *         if(lastTimeSeconds){\n   *             var deltaTime = timeSeconds - lastTimeSeconds;\n   *             world.step(fixedTimeStep, deltaTime, maxSubSteps);\n   *         }\n   *\n   *         lastTimeSeconds = timeSeconds;\n   *\n   *         renderBody(body.interpolatedPosition, body.interpolatedAngle);\n   *     }\n   *\n   *     // Start animation loop\n   *     requestAnimationFrame(animate);\n   *\n   * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n   */\n  step(dt, timeSinceLastCalled, maxSubSteps) {\n    if (maxSubSteps === void 0) {\n      maxSubSteps = 10;\n    }\n    if (timeSinceLastCalled === undefined) {\n      // Fixed, simple stepping\n      this.internalStep(dt);\n\n      // Increment time\n      this.time += dt;\n    } else {\n      this.accumulator += timeSinceLastCalled;\n      let substeps = 0;\n      while (this.accumulator >= dt && substeps < maxSubSteps) {\n        // Do fixed steps to catch up\n        this.internalStep(dt);\n        this.time += dt;\n        this.accumulator -= dt;\n        substeps++;\n      }\n      const t = this.accumulator % dt / dt;\n      for (let j = 0; j !== this.bodies.length; j++) {\n        const b = this.bodies[j];\n        lerp(b.interpolatedPosition, b.previousPosition, b.position, t);\n        b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);\n      }\n    }\n  }\n\n  /**\n   * Make a fixed step.\n   * @param dt\n   */\n  internalStep(dt) {\n    this.stepping = true;\n    const Nsprings = this.springs.length,\n      springs = this.springs,\n      bodies = this.bodies,\n      g = this.gravity,\n      solver = this.solver,\n      Nbodies = this.bodies.length,\n      broadphase = this.broadphase,\n      np = this.narrowphase,\n      constraints = this.constraints,\n      mg = step_mg,\n      add$1 = add;\n    this.overlapKeeper.tick();\n    this.lastTimeStep = dt;\n\n    // Update approximate friction gravity.\n    if (this.useWorldGravityAsFrictionGravity) {\n      const gravityLen = length(this.gravity);\n      if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {\n        // Nonzero gravity. Use it.\n        this.frictionGravity = gravityLen;\n      }\n    }\n\n    // Add gravity to bodies\n    if (this.applyGravity) {\n      for (let i = 0; i !== Nbodies; i++) {\n        const b = bodies[i],\n          fi = b.force;\n        if (b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING) {\n          continue;\n        }\n        scale(mg, g, b.mass * b.gravityScale); // F=m*g\n        add$1(fi, fi, mg);\n      }\n    }\n\n    // Add spring forces\n    if (this.applySpringForces) {\n      for (let i = 0; i !== Nsprings; i++) {\n        const s = springs[i];\n        s.applyForce();\n      }\n    }\n\n    // Apply damping\n    if (this.applyDamping) {\n      for (let i = 0; i !== Nbodies; i++) {\n        const b = bodies[i];\n        if (b.type === Body.DYNAMIC) {\n          b.applyDamping(dt);\n        }\n      }\n    }\n\n    // Get Broadphase collision pairs\n    const result = broadphase.getCollisionPairs(this);\n\n    // Remove ignored collision pairs\n    const ignoredPairs = this.disabledBodyCollisionPairs;\n    for (let i = ignoredPairs.length - 2; i >= 0; i -= 2) {\n      for (let j = result.length - 2; j >= 0; j -= 2) {\n        if (ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1] || ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1]) {\n          result.splice(j, 2);\n        }\n      }\n    }\n\n    // Remove constrained pairs with collideConnected == false\n    let Nconstraints = constraints.length;\n    for (let i = 0; i !== Nconstraints; i++) {\n      const c = constraints[i];\n      if (!c.collideConnected) {\n        for (let j = result.length - 2; j >= 0; j -= 2) {\n          if (c.bodyA === result[j] && c.bodyB === result[j + 1] || c.bodyB === result[j] && c.bodyA === result[j + 1]) {\n            result.splice(j, 2);\n          }\n        }\n      }\n    }\n\n    // postBroadphase event\n    this.emit({\n      type: 'postBroadphase',\n      pairs: result\n    });\n\n    // Narrowphase\n    np.reset();\n    const defaultContactMaterial = this.defaultContactMaterial;\n    const frictionGravity = this.frictionGravity;\n    for (let i = 0, Nresults = result.length; i !== Nresults; i += 2) {\n      const bi = result[i];\n      const bj = result[i + 1];\n\n      // Loop over all shapes of body i\n      for (let k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {\n        const si = bi.shapes[k];\n        const xi = si.position;\n        const ai = si.angle;\n\n        // All shapes of body j\n        for (let l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {\n          const sj = bj.shapes[l];\n          const xj = sj.position;\n          const aj = sj.angle;\n          let contactMaterial = false;\n          if (si.material && sj.material) {\n            contactMaterial = this.getContactMaterial(si.material, sj.material);\n          }\n          runNarrowphase(this, np, bi, si, xi, ai, bj, sj, xj, aj, contactMaterial || defaultContactMaterial, frictionGravity);\n        }\n      }\n    }\n\n    // Wake up bodies\n    for (let i = 0; i !== Nbodies; i++) {\n      const body = bodies[i];\n      if (body._wakeUpAfterNarrowphase) {\n        body.wakeUp();\n        body._wakeUpAfterNarrowphase = false;\n      }\n    }\n\n    // Emit end overlap events\n    if (this.has('endContact')) {\n      this.overlapKeeper.getEndOverlaps(endOverlaps);\n      let l = endOverlaps.length;\n      while (l--) {\n        const data = endOverlaps[l];\n        const e = {\n          type: 'endContact',\n          shapeA: data.shapeA,\n          shapeB: data.shapeB,\n          bodyA: data.bodyA,\n          bodyB: data.bodyB\n        };\n        this.emit(e);\n      }\n      endOverlaps.length = 0;\n    }\n    this.emit({\n      type: 'preSolve',\n      contactEquations: np.contactEquations,\n      frictionEquations: np.frictionEquations\n    });\n\n    // update constraint equations\n    Nconstraints = constraints.length;\n    for (let i = 0; i !== Nconstraints; i++) {\n      constraints[i].update();\n    }\n    if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {\n      // Get all equations\n      let equations = [];\n      appendArray(equations, np.contactEquations);\n      appendArray(equations, np.frictionEquations);\n      for (let i = 0; i !== Nconstraints; i++) {\n        appendArray(equations, constraints[i].equations);\n      }\n      if (this.islandSplit) {\n        // Initialize the UnionFind\n        const unionFind = this.unionFind;\n        unionFind.resize(this.bodies.length + 1);\n\n        // Update equation index\n        for (let i = 0; i < equations.length; i++) {\n          equations[i].index = i;\n        }\n\n        // Unite bodies if they are connected by an equation\n        for (let i = 0; i < equations.length; i++) {\n          const bodyA = equations[i].bodyA;\n          const bodyB = equations[i].bodyB;\n          if (bodyA.type === Body.DYNAMIC && bodyB.type === Body.DYNAMIC) {\n            unionFind.union(bodyA.index, bodyB.index);\n          }\n        }\n\n        // Find the body islands\n        for (let i = 0; i < bodies.length; i++) {\n          const body = bodies[i];\n          body.islandId = body.type === Body.DYNAMIC ? unionFind.find(body.index) : -1;\n        }\n\n        // Sort equations by island\n        equations = equations.sort(sortEquationsByIsland);\n        let equationIndex = 0;\n        while (equationIndex < equations.length) {\n          const equation = equations[equationIndex++];\n          solver.addEquation(equation);\n          const currentIslandId = equation.bodyA.islandId > 0 ? equation.bodyA.islandId : equation.bodyB.islandId;\n          let nextIslandId = -1;\n          if (equations[equationIndex]) {\n            nextIslandId = equations[equationIndex].bodyA.islandId > 0 ? equations[equationIndex].bodyA.islandId : equations[equationIndex].bodyB.islandId;\n          }\n          if (nextIslandId !== currentIslandId || equationIndex === equations.length) {\n            // Solve this island\n            if (this.solveConstraints) {\n              solver.solve(dt, this);\n            }\n            solver.removeAllEquations();\n          }\n        }\n      } else {\n        // Solve all as one island\n        solver.addEquations(equations);\n        if (this.solveConstraints) {\n          solver.solve(dt, this);\n        }\n        solver.removeAllEquations();\n      }\n    }\n\n    // Step forward\n    for (let i = 0; i !== Nbodies; i++) {\n      const body = bodies[i];\n      if (body.type === Body.DYNAMIC || body.type === Body.KINEMATIC) {\n        body.integrate(dt);\n      }\n    }\n\n    // Reset force\n    for (let i = 0; i !== Nbodies; i++) {\n      bodies[i].setZeroForce();\n    }\n\n    // Emit impact event\n    if (this.emitImpactEvent && this.has('impact')) {\n      for (let i = 0; i !== np.contactEquations.length; i++) {\n        const eq = np.contactEquations[i];\n        if (eq.firstImpact) {\n          this.emit({\n            type: 'impact',\n            bodyA: eq.bodyA,\n            bodyB: eq.bodyB,\n            shapeA: eq.shapeA,\n            shapeB: eq.shapeB,\n            contactEquation: eq\n          });\n        }\n      }\n    }\n\n    // Sleeping update\n    let hasActiveBodies = true;\n    if (this.sleepMode === World.BODY_SLEEPING) {\n      hasActiveBodies = false;\n      for (let i = 0; i !== Nbodies; i++) {\n        const body = bodies[i];\n        body.sleepTick(this.time, false, dt);\n\n        // Check if the body is not sleeping\n        if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {\n          hasActiveBodies = true;\n        }\n      }\n    } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {\n      // Tell all bodies to sleep tick but dont sleep yet\n      for (let i = 0; i !== Nbodies; i++) {\n        bodies[i].sleepTick(this.time, true, dt);\n      }\n\n      // Sleep islands\n      const bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);\n      let islandEnd = 1;\n      for (let islandStart = 0; islandStart < bodiesSortedByIsland.length; islandStart = islandEnd) {\n        const islandId = bodiesSortedByIsland[islandStart].islandId;\n\n        // Get islandEnd index\n        for (islandEnd = islandStart + 1; islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++ // eslint-disable-next-line no-empty\n        ) {}\n\n        // Don't check static objects\n        if (islandId === -1) {\n          continue;\n        }\n        let islandShouldSleep = true;\n        for (let i = islandStart; i < islandEnd; i++) {\n          if (!bodiesSortedByIsland[i].wantsToSleep) {\n            islandShouldSleep = false;\n            break;\n          }\n        }\n        if (islandShouldSleep) {\n          for (let i = islandStart; i < islandEnd; i++) {\n            bodiesSortedByIsland[i].sleep();\n          }\n        }\n      }\n\n      // Check if any bodies are not sleeping\n      hasActiveBodies = false;\n      for (let i = 0; i !== Nbodies; i++) {\n        const body = bodies[i];\n        if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {\n          hasActiveBodies = true;\n          break;\n        }\n      }\n    }\n    this.hasActiveBodies = hasActiveBodies;\n    this.stepping = false;\n    this.emit({\n      type: 'postStep'\n    });\n  }\n\n  /**\n   * Add a spring to the simulation. Note that this operation can't be done during step.\n   * @param spring\n   */\n  addSpring(spring) {\n    if (this.stepping) {\n      throw new Error('Springs cannot be added during step.');\n    }\n    this.springs.push(spring);\n    this.emit({\n      type: 'addSpring',\n      spring\n    });\n  }\n\n  /**\n   * Remove a spring. Note that this operation can't be done during step.\n   * @param spring\n   */\n  removeSpring(spring) {\n    if (this.stepping) {\n      throw new Error('Springs cannot be removed during step.');\n    }\n    arrayRemove(this.springs, spring);\n    this.emit({\n      type: 'removeSpring',\n      spring\n    });\n  }\n\n  /**\n   * Add a body to the simulation. Note that you can't add a body during step: you have to wait until after the step (see the postStep event).\n   * Also note that bodies can only be added to one World at a time.\n   * @param body\n   *\n   * @example\n   *     var world = new World(),\n   *         body = new Body();\n   *     world.addBody(body);\n   */\n  addBody(body) {\n    if (this.stepping) {\n      throw new Error('Bodies cannot be added during step.');\n    }\n\n    // Already added?\n    if (body.world) {\n      throw new Error('Body is already added to a World.');\n    }\n    body.index = this.bodies.length;\n    this.bodies.push(body);\n    body.world = this;\n    this.emit({\n      type: 'addBody',\n      body\n    });\n  }\n\n  /**\n   * Remove a body from the simulation. Note that bodies cannot be removed during step (for example, inside the beginContact event). In that case you need to wait until the step is done (see the postStep event).\n   *\n   * Also note that any constraints connected to the body must be removed before the body.\n   *\n   * @param body\n   *\n   * @example\n   *     var removeBody;\n   *     world.on(\"beginContact\",function(event){\n   *         // We cannot remove the body here since the world is still stepping.\n   *         // Instead, schedule the body to be removed after the step is done.\n   *         removeBody = body;\n   *     });\n   *     world.on(\"postStep\",function(event){\n   *         if(removeBody){\n   *             // Safely remove the body from the world.\n   *             world.removeBody(removeBody);\n   *             removeBody = null;\n   *         }\n   *     });\n   */\n  removeBody(body) {\n    if (this.stepping) {\n      throw new Error('Bodies cannot be removed during step.');\n    }\n\n    // TODO: would it be smart to have a .constraints array on the body?\n    const constraints = this.constraints;\n    let l = constraints.length;\n    while (l--) {\n      if (constraints[l].bodyA === body || constraints[l].bodyB === body) {\n        throw new Error('Cannot remove Body from World: it still has constraints connected to it.');\n      }\n    }\n    body.world = null;\n    const bodies = this.bodies;\n    arrayRemove(bodies, body);\n    body.index = -1;\n    l = bodies.length;\n    while (l--) {\n      bodies[l].index = l;\n    }\n    body.resetConstraintVelocity();\n\n    // Emit removeBody event\n    this.emit({\n      type: 'removeBody',\n      body\n    });\n\n    // Remove disabled body collision pairs that involve body\n    const pairs = this.disabledBodyCollisionPairs;\n    let i = 0;\n    while (i < pairs.length) {\n      if (pairs[i] === body || pairs[i + 1] === body) {\n        pairs.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * Get a body by its id.\n   * @param id\n   * @returns The body, or false if it was not found.\n   */\n  getBodyByID(id) {\n    const bodies = this.bodies;\n    for (let i = 0; i < bodies.length; i++) {\n      const b = bodies[i];\n      if (b.id === id) {\n        return b;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Disable collision between two bodies\n   * @param bodyA\n   * @param bodyB\n   */\n  disableBodyCollision(bodyA, bodyB) {\n    this.disabledBodyCollisionPairs.push(bodyA, bodyB);\n  }\n\n  /**\n   * Enable collisions between the given two bodies, if they were previously disabled using .disableBodyCollision().\n   * @param bodyA\n   * @param bodyB\n   */\n  enableBodyCollision(bodyA, bodyB) {\n    const pairs = this.disabledBodyCollisionPairs;\n    for (let i = 0; i < pairs.length; i += 2) {\n      if (pairs[i] === bodyA && pairs[i + 1] === bodyB || pairs[i + 1] === bodyA && pairs[i] === bodyB) {\n        pairs.splice(i, 2);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Removes all bodies, constraints, springs, and contact materials from the world.\n   */\n  clear() {\n    // Remove all solver equations\n    this.solver.removeAllEquations();\n\n    // Remove all constraints\n    const cs = this.constraints;\n    let i = cs.length;\n    while (i--) {\n      this.removeConstraint(cs[i]);\n    }\n\n    // Remove all bodies\n    const bodies = this.bodies;\n    i = bodies.length;\n    while (i--) {\n      this.removeBody(bodies[i]);\n    }\n\n    // Remove all springs\n    const springs = this.springs;\n    i = springs.length;\n    while (i--) {\n      this.removeSpring(springs[i]);\n    }\n\n    // Remove all contact materials\n    const cms = this.contactMaterials;\n    i = cms.length;\n    while (i--) {\n      this.removeContactMaterial(cms[i]);\n    }\n  }\n\n  /**\n   * Test if a world point overlaps bodies\n   * @param worldPoint Point to use for intersection tests\n   * @param bodies A list of objects to check for intersection\n   * @param precision Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n   * @returns Array of bodies that overlap the point\n   *\n   * @todo Should use an api similar to the raycast function\n   * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient\n   * @todo Should use the broadphase\n   * @todo Returning the hit shape would be fine - it carries a reference to the body now\n   */\n  hitTest(worldPoint, bodies, precision) {\n    if (precision === void 0) {\n      precision = 0;\n    }\n    // Create a dummy particle body with a particle shape to test against the bodies\n    const shapeWorldPosition = hitTest_tmp1,\n      shapeLocalPoint = hitTest_tmp2;\n    const result = [];\n\n    // Check bodies\n    for (let i = 0, N = bodies.length; i !== N; i++) {\n      const body = bodies[i];\n      for (let j = 0, NS = body.shapes.length; j !== NS; j++) {\n        const shape = body.shapes[j];\n\n        // Get local point position in the shape\n        shape.worldPointToLocal(shapeLocalPoint, worldPoint);\n        if (shape.pointTest(shapeLocalPoint)) {\n          result.push(body);\n        } else {\n          // Get shape world position\n          rotate(shapeWorldPosition, shape.position, body.angle);\n          add(shapeWorldPosition, shapeWorldPosition, body.position);\n          if (shape.type === Shape.PARTICLE && squaredDistance(shapeWorldPosition, worldPoint) < precision * precision) {\n            result.push(body);\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Set the stiffness for all equations and contact materials.\n   * @param stiffness\n   */\n  setGlobalStiffness(stiffness) {\n    this.setGlobalEquationParameters({\n      stiffness: stiffness\n    });\n\n    // Set for all contact materials\n    const contactMaterials = this.contactMaterials;\n    for (let i = 0; i !== contactMaterials.length; i++) {\n      const c = contactMaterials[i];\n      c.stiffness = c.frictionStiffness = stiffness;\n    }\n\n    // Set for default contact material\n    const c = this.defaultContactMaterial;\n    c.stiffness = c.frictionStiffness = stiffness;\n  }\n\n  /**\n   * Set the relaxation for all equations and contact materials.\n   * @param relaxation\n   */\n  setGlobalRelaxation(relaxation) {\n    this.setGlobalEquationParameters({\n      relaxation: relaxation\n    });\n\n    // Set for all contact materials\n    for (let i = 0; i !== this.contactMaterials.length; i++) {\n      const c = this.contactMaterials[i];\n      c.relaxation = c.frictionRelaxation = relaxation;\n    }\n\n    // Set for default contact material\n    const c = this.defaultContactMaterial;\n    c.relaxation = c.frictionRelaxation = relaxation;\n  }\n\n  /**\n   * Ray cast against all bodies in the world.\n   * @param result\n   * @param ray\n   * @return true if any body was hit\n   * @example\n   *     var ray = new Ray({\n   *         mode: Ray.ALL,\n   *         from: [0, 0],\n   *         to: [10, 0],\n   *         callback: function(result){\n   *\n   *             // Print some info about the hit\n   *             console.log('Hit body and shape: ', result.body, result.shape);\n   *\n   *             // Get the hit point\n   *             var hitPoint = vec2.create();\n   *             result.getHitPoint(hitPoint, ray);\n   *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n   *\n   *             // If you are happy with the hits you got this far, you can stop the traversal here:\n   *             result.stop();\n   *         }\n   *     });\n   *     var result = new RaycastResult();\n   *     world.raycast(result, ray);\n   * @param result\n   * @param ray\n   */\n  raycast(result, ray) {\n    // Get all bodies within the ray AABB\n    ray.getAABB(tmpRaycastAABB);\n    this.broadphase.aabbQuery(this, tmpRaycastAABB, tmpRaycastArray);\n    ray.intersectBodies(result, tmpRaycastArray);\n    tmpRaycastArray.length = 0;\n    return result.hasHit();\n  }\n  setGlobalEquationParameters(parameters) {\n    const constraints = this.constraints;\n    for (let i = 0; i !== constraints.length; i++) {\n      const c = constraints[i];\n      const eqs = c.equations;\n      for (let j = 0; j !== eqs.length; j++) {\n        const eq = eqs[j];\n        eq.relaxation = parameters.relaxation ?? eq.relaxation;\n        eq.stiffness = parameters.stiffness ?? eq.stiffness;\n        eq.needsUpdate = true;\n      }\n    }\n  }\n}\nfunction sortBodiesByIsland(a, b) {\n  return a.islandId - b.islandId;\n}\nfunction sortEquationsByIsland(equationA, equationB) {\n  const islandA = equationA.bodyA.islandId > 0 ? equationA.bodyA.islandId : equationA.bodyB.islandId;\n  const islandB = equationB.bodyA.islandId > 0 ? equationB.bodyA.islandId : equationB.bodyB.islandId;\n  if (islandA !== islandB) {\n    return islandA - islandB;\n  } else {\n    // Sort by equation type if same island\n    return equationA.index - equationB.index;\n  }\n}\n\n// Check collision groups and masks\nfunction runNarrowphase(world, np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {\n  if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {\n    return;\n  }\n\n  // Get world position and angle of each shape\n  toGlobalFrame(xiw, xi, bi.position, bi.angle);\n  toGlobalFrame(xjw, xj, bj.position, bj.angle);\n  if (distance(xiw, xjw) > si.boundingRadius + sj.boundingRadius) {\n    return;\n  }\n  const aiw = ai + bi.angle;\n  const ajw = aj + bj.angle;\n  np.enableFriction = cm.friction > 0;\n  let reducedMass;\n  if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {\n    reducedMass = bj.mass;\n  } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {\n    reducedMass = bi.mass;\n  } else {\n    reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);\n  }\n  np.slipForce = cm.friction * glen * reducedMass;\n  np.currentContactMaterial = cm;\n  np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n  const resolver = np.narrowphases[si.type | sj.type];\n  let numContacts = 0;\n  if (resolver) {\n    const sensor = si.sensor || sj.sensor;\n    const numFrictionBefore = np.frictionEquations.length;\n    if (si.type < sj.type) {\n      numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);\n    } else {\n      numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);\n    }\n    const numFrictionEquations = np.frictionEquations.length - numFrictionBefore;\n    if (numContacts) {\n      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {\n        const speedSquaredB = squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);\n        const speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);\n        if (speedSquaredB >= speedLimitSquaredB * 2) {\n          bi._wakeUpAfterNarrowphase = true;\n        }\n      }\n      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {\n        const speedSquaredA = squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);\n        const speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);\n        if (speedSquaredA >= speedLimitSquaredA * 2) {\n          bj._wakeUpAfterNarrowphase = true;\n        }\n      }\n      world.overlapKeeper.setOverlapping(bi, si, bj, sj);\n      if (world.has('beginContact') && world.overlapKeeper.isNewOverlap(si, sj)) {\n        // Report new shape overlap\n        const equations = [];\n        if (!sensor) {\n          for (let i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {\n            equations.push(np.contactEquations[i]);\n          }\n        }\n        world.emit({\n          type: 'beginContact',\n          shapeA: si,\n          shapeB: sj,\n          bodyA: bi,\n          bodyB: bj,\n          contactEquations: equations\n        });\n      }\n\n      // divide the max friction force by the number of contacts\n      if (!sensor && numFrictionEquations > 1) {\n        // Why divide by 1?\n        for (let i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {\n          const f = np.frictionEquations[i];\n          f.setSlipForce(f.getSlipForce() / numFrictionEquations);\n        }\n      }\n    }\n  }\n}\nconst tmpRaycastAABB = new AABB();\nconst tmpRaycastArray = [];\nconst step_mg = create(),\n  xiw = create(),\n  xjw = create();\nconst endOverlaps = [];\nconst hitTest_tmp1 = create(),\n  hitTest_tmp2 = create();\n\nexport { AABB, AngleLockEquation, Body, Box, Broadphase, Capsule, Circle, Constraint, ContactEquation, ContactEquationPool, ContactMaterial, Convex, DistanceConstraint, Equation, EventEmitter, FrictionEquation, FrictionEquationPool, GSSolver, GearConstraint, Heightfield, Line, LinearSpring, LockConstraint, Material, NaiveBroadphase, Narrowphase, Particle, Plane, Pool, PrismaticConstraint, Ray, RaycastResult, RevoluteConstraint, RotationalSpring, RotationalVelocityEquation, SAPBroadphase, Shape, Solver, Spring, TopDownVehicle, Utils, WheelConstraint, World, vec2 };\n"],
  "mappings": "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",
  "names": ["t", "dot", "points", "l", "tmp", "tmp1", "tmp2", "distance", "n", "i", "vi", "v0", "r", "relativePoint", "vj", "ri", "rj", "tmpVec", "worldAnchorA", "worldAnchorB", "bodyA", "bodyB", "g", "c", "shapeWorldPosition"]
}
